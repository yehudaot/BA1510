CCS PCH C Compiler, Version 4.137, 5967               18-Jun-18 18:21

               Filename: D:\Projects\BA\BA1510\embedded\project\BA1510_Bootloader.lst

               ROM used: 5430 bytes (17%)
                         Largest free fragment is 24576
               RAM used: 899 (58%) at main() level
                         1018 (66%) worst case
               Stack:    9 worst case (7 in main + 2 for interrupts)

*
0000:  GOTO   0100
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   00C6
0060:  BTFSS  F9D.4
0062:  GOTO   006C
0066:  BTFSC  F9E.4
0068:  GOTO   0912
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
....................  
.................... #include "BA1474.h" 
.................... #include <18F45K22.h> 
.................... //////// Standard Header file for the PIC18F45K22 device //////////////// 
.................... #device PIC18F45K22 
.................... #list 
....................  
.................... #device adc=10 
.................... #device pass_strings=in_ram 
....................  
.................... #define LOADER_END 0x1FFF 
.................... #include <boot.h> 
.................... #undef LOADER_END 
.................... #define FLASH_SIZE getenv("FLASH_ERASE_SIZE") 
.................... #define LOADER_END   0x1FFF 
.................... #define LOADER_SIZE  0x3FF 
....................  
.................... #ifndef _bootloader 
.................... #build(reset=LOADER_END+1, interrupt=LOADER_END+9) 
....................  
.................... /* when in operational software, keep out of the bootloader sections */ 
.................... #org 0, 0xfff {} 
.................... #org 0x1000, 0x1ffe {} 
....................  
.................... #else 
....................  
.................... /* when in the bootloader, keep out of the operational sections */ 
.................... #org 0x2000, 0x7ffe {} 
....................  
.................... #endif 
....................  
....................  
.................... #FUSES NOWDT                   //No Watch Dog Timer 
.................... #FUSES WDT128                  //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES INTRC_IO                //Internal RC Osc, no CLKOUT 
.................... #FUSES NOBROWNOUT              //No brownout reset 
.................... #FUSES WDT_SW                  //No Watch Dog Timer, enabled in Software 
.................... #FUSES NOLVP                   //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOPUT 
.................... #FUSES NOXINST                 //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(clock=64000000) 
*
0A2A:  MOVLW  01
0A2C:  MOVLB  3
0A2E:  SUBWF  x8A,F
0A30:  BNC   0A4A
0A32:  MOVLW  03
0A34:  MOVWF  FEA
0A36:  MOVLW  8A
0A38:  MOVWF  FE9
0A3A:  MOVF   FEF,W
0A3C:  BZ    0A4A
0A3E:  MOVLW  04
0A40:  MOVWF  00
0A42:  DECFSZ 00,F
0A44:  BRA    0A42
0A46:  DECFSZ FEF,F
0A48:  BRA    0A3E
0A4A:  MOVLB  0
0A4C:  GOTO   06F2 (RETURN)
*
0B36:  MOVLW  03
0B38:  MOVWF  FEA
0B3A:  MOVLW  E3
0B3C:  MOVWF  FE9
0B3E:  MOVF   FEF,W
0B40:  BZ    0B5E
0B42:  MOVLW  14
0B44:  MOVWF  01
0B46:  CLRF   00
0B48:  DECFSZ 00,F
0B4A:  BRA    0B48
0B4C:  DECFSZ 01,F
0B4E:  BRA    0B46
0B50:  MOVLW  BF
0B52:  MOVWF  00
0B54:  DECFSZ 00,F
0B56:  BRA    0B54
0B58:  BRA    0B5A
0B5A:  DECFSZ FEF,F
0B5C:  BRA    0B42
0B5E:  RETURN 0
.................... #use rs232(baud=921600,xmit=PIN_C6,rcv=PIN_C7,ERRORS) 
.................... #USE TIMER(TIMER=1,TICK=1us,BITS=32,NOISR) 
.................... #use spi(DO=PIN_A4, CLK=PIN_A3, ENABLE=PIN_A2, ENABLE_ACTIVE=0, DATA_HOLD=20, BITS=16) 
....................  
.................... #opt 9 
....................  
.................... #use fast_io(a) 
.................... #use fast_io(b) 
.................... #use fast_io(c) 
.................... #use fast_io(d) 
.................... #use fast_io(e) 
....................  
.................... #define safe_write_program_memory(address, pointer, size) \ 
....................   do { disable_interrupts(GLOBAL); write_program_memory(address, pointer, size); enable_interrupts(GLOBAL); delay_us(1000); } while (0) 
....................  
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include "crc8.h" 
.................... #ifndef __CRC8__ 
.................... #define __CRC8__ 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... uint8_t crc8(uint8_t* buffer, uint16_t size); 
....................  
.................... #endif 
....................  
....................  
.................... // Polynom 0x2F 
.................... static const uint8_t crc8_table[256] = { 
....................   0x00, 0x2F, 0x5E, 0x71, 0xBC, 0x93, 0xE2, 0xCD, 
....................   0x57, 0x78, 0x09, 0x26, 0xEB, 0xC4, 0xB5, 0x9A, 
....................   0xAE, 0x81, 0xF0, 0xDF, 0x12, 0x3D, 0x4C, 0x63, 
....................   0xF9, 0xD6, 0xA7, 0x88, 0x45, 0x6A, 0x1B, 0x34, 
....................   0x73, 0x5C, 0x2D, 0x02, 0xCF, 0xE0, 0x91, 0xBE, 
....................   0x24, 0x0B, 0x7A, 0x55, 0x98, 0xB7, 0xC6, 0xE9, 
....................   0xDD, 0xF2, 0x83, 0xAC, 0x61, 0x4E, 0x3F, 0x10, 
....................   0x8A, 0xA5, 0xD4, 0xFB, 0x36, 0x19, 0x68, 0x47, 
....................   0xE6, 0xC9, 0xB8, 0x97, 0x5A, 0x75, 0x04, 0x2B, 
....................   0xB1, 0x9E, 0xEF, 0xC0, 0x0D, 0x22, 0x53, 0x7C, 
....................   0x48, 0x67, 0x16, 0x39, 0xF4, 0xDB, 0xAA, 0x85, 
....................   0x1F, 0x30, 0x41, 0x6E, 0xA3, 0x8C, 0xFD, 0xD2, 
....................   0x95, 0xBA, 0xCB, 0xE4, 0x29, 0x06, 0x77, 0x58, 
....................   0xC2, 0xED, 0x9C, 0xB3, 0x7E, 0x51, 0x20, 0x0F, 
....................   0x3B, 0x14, 0x65, 0x4A, 0x87, 0xA8, 0xD9, 0xF6, 
....................   0x6C, 0x43, 0x32, 0x1D, 0xD0, 0xFF, 0x8E, 0xA1, 
....................   0xE3, 0xCC, 0xBD, 0x92, 0x5F, 0x70, 0x01, 0x2E, 
....................   0xB4, 0x9B, 0xEA, 0xC5, 0x08, 0x27, 0x56, 0x79, 
....................   0x4D, 0x62, 0x13, 0x3C, 0xF1, 0xDE, 0xAF, 0x80, 
....................   0x1A, 0x35, 0x44, 0x6B, 0xA6, 0x89, 0xF8, 0xD7, 
....................   0x90, 0xBF, 0xCE, 0xE1, 0x2C, 0x03, 0x72, 0x5D, 
....................   0xC7, 0xE8, 0x99, 0xB6, 0x7B, 0x54, 0x25, 0x0A, 
....................   0x3E, 0x11, 0x60, 0x4F, 0x82, 0xAD, 0xDC, 0xF3, 
....................   0x69, 0x46, 0x37, 0x18, 0xD5, 0xFA, 0x8B, 0xA4, 
....................   0x05, 0x2A, 0x5B, 0x74, 0xB9, 0x96, 0xE7, 0xC8, 
....................   0x52, 0x7D, 0x0C, 0x23, 0xEE, 0xC1, 0xB0, 0x9F, 
....................   0xAB, 0x84, 0xF5, 0xDA, 0x17, 0x38, 0x49, 0x66, 
....................   0xFC, 0xD3, 0xA2, 0x8D, 0x40, 0x6F, 0x1E, 0x31, 
....................   0x76, 0x59, 0x28, 0x07, 0xCA, 0xE5, 0x94, 0xBB, 
....................   0x21, 0x0E, 0x7F, 0x50, 0x9D, 0xB2, 0xC3, 0xEC, 
....................   0xD8, 0xF7, 0x86, 0xA9, 0x64, 0x4B, 0x3A, 0x15, 
....................   0x8F, 0xA0, 0xD1, 0xFE, 0x33, 0x1C, 0x6D, 0x42 
.................... }; 
....................  
.................... uint8_t crc8(uint8_t* buffer, uint16_t size) { 
*
0D88:  MOVLB  3
0D8A:  CLRF   xEF
....................   uint8_t crc = 0; 
....................  
....................   while (size-- > 0) { 
0D8C:  MOVFF  3EE,03
0D90:  MOVF   xED,W
0D92:  BTFSC  FD8.2
0D94:  DECF   xEE,F
0D96:  DECF   xED,F
0D98:  MOVWF  xF1
0D9A:  MOVFF  03,3F2
0D9E:  MOVF   xF1,F
0DA0:  BNZ   0DA6
0DA2:  MOVF   xF2,F
0DA4:  BZ    0DCE
....................     uint8_t pos = (*buffer++) ^ crc; 
0DA6:  MOVFF  3EC,03
0DAA:  MOVF   xEB,W
0DAC:  INCF   xEB,F
0DAE:  BTFSC  FD8.2
0DB0:  INCF   xEC,F
0DB2:  MOVWF  FE9
0DB4:  MOVFF  03,FEA
0DB8:  MOVF   FEF,W
0DBA:  XORWF  xEF,W
0DBC:  MOVWF  xF0
....................     crc = crc8_table[pos]; 
0DBE:  CLRF   03
0DC0:  MOVF   xF0,W
0DC2:  MOVLB  0
0DC4:  RCALL  0802
0DC6:  MOVFF  FE8,3EF
....................   } 
0DCA:  MOVLB  3
0DCC:  BRA    0D8C
....................   return crc; 
0DCE:  MOVFF  3EF,01
.................... } 
0DD2:  MOVLB  0
0DD4:  RETURN 0
....................  
.................... /* 
....................  * comm.c 
....................  * 
....................  *  Created on: Mar 23, 2017 
....................  *      Author: asaf 
....................  */ 
....................  
.................... #include "BA1474.h" 
.................... #include <18F45K22.h> 
.................... //////// Standard Header file for the PIC18F45K22 device //////////////// 
.................... #device PIC18F45K22 
.................... #list 
....................  
.................... #device adc=10 
.................... #device pass_strings=in_ram 
....................  
.................... #define LOADER_END 0x1FFF 
.................... #include <boot.h> 
.................... #undef LOADER_END 
.................... #define FLASH_SIZE getenv("FLASH_ERASE_SIZE") 
.................... #define LOADER_END   0x1FFF 
.................... #define LOADER_SIZE  0x3FF 
....................  
.................... #ifndef _bootloader 
.................... #build(reset=LOADER_END+1, interrupt=LOADER_END+9) 
....................  
.................... /* when in operational software, keep out of the bootloader sections */ 
.................... #org 0, 0xfff {} 
.................... #org 0x1000, 0x1ffe {} 
....................  
.................... #else 
....................  
.................... /* when in the bootloader, keep out of the operational sections */ 
.................... #org 0x2000, 0x7ffe {} 
....................  
.................... #endif 
....................  
....................  
.................... #FUSES NOWDT                   //No Watch Dog Timer 
.................... #FUSES WDT128                  //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES INTRC_IO                //Internal RC Osc, no CLKOUT 
.................... #FUSES NOBROWNOUT              //No brownout reset 
.................... #FUSES WDT_SW                  //No Watch Dog Timer, enabled in Software 
.................... #FUSES NOLVP                   //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOPUT 
.................... #FUSES NOXINST                 //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(clock=64000000) 
.................... #use rs232(baud=921600,xmit=PIN_C6,rcv=PIN_C7,ERRORS) 
.................... #USE TIMER(TIMER=1,TICK=1us,BITS=32,NOISR) 
.................... #use spi(DO=PIN_A4, CLK=PIN_A3, ENABLE=PIN_A2, ENABLE_ACTIVE=0, DATA_HOLD=20, BITS=16) 
....................  
.................... #opt 9 
....................  
.................... #use fast_io(a) 
.................... #use fast_io(b) 
.................... #use fast_io(c) 
.................... #use fast_io(d) 
.................... #use fast_io(e) 
....................  
.................... #define safe_write_program_memory(address, pointer, size) \ 
....................   do { disable_interrupts(GLOBAL); write_program_memory(address, pointer, size); enable_interrupts(GLOBAL); delay_us(1000); } while (0) 
....................  
....................  
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdbool.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                          stdbool.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard boolean definitions                                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __STDBOOL_H__ 
.................... #define __STDBOOL_H__ 
....................  
.................... //remove TRUE and FALSE added by CCS's device .h file 
.................... #if defined(TRUE) 
.................... #undef TRUE 
.................... #endif 
.................... #if defined(FALSE) 
.................... #undef FALSE 
.................... #endif 
....................  
.................... typedef int1   bool; 
.................... #define true   1 
.................... #define false  0 
.................... #define __bool_true_false_are_defined  1 
....................  
.................... #endif 
....................  
....................  
.................... #include "comm.h" 
.................... /* 
....................  * comm.h 
....................  * 
....................  *  Created on: Mar 23, 2017 
....................  *      Author: asaf 
....................  */ 
....................  
.................... #ifndef COMM_H_ 
.................... #define COMM_H_ 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdbool.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                          stdbool.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard boolean definitions                                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __STDBOOL_H__ 
.................... #define __STDBOOL_H__ 
....................  
.................... //remove TRUE and FALSE added by CCS's device .h file 
.................... #if defined(TRUE) 
.................... #undef TRUE 
.................... #endif 
.................... #if defined(FALSE) 
.................... #undef FALSE 
.................... #endif 
....................  
.................... typedef int1   bool; 
.................... #define true   1 
.................... #define false  0 
.................... #define __bool_true_false_are_defined  1 
....................  
.................... #endif 
....................  
....................  
.................... #define MSG_MAX_MESSAGE_LEN 80 
....................  
.................... #ifndef MIN 
.................... #define MIN(x,y) ((x)<(y)?(x):(y)) 
.................... #endif 
.................... #ifndef MAX 
.................... #define	MAX(a,b) (((a)>(b))?(a):(b)) 
.................... #endif 
....................  
.................... #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0])) 
.................... #define MAX_INDEX_IN_ARRAY(x) (ARRAY_SIZE(x)-1) 
....................  
.................... void comm_init(); 
.................... bool comm_receive_message(void* buffer, uint16_t* size); 
.................... void comm_send_message(void* buffer, uint16_t size); 
....................  
....................  
....................  
.................... #endif /* COMM_H_ */ 
....................  
.................... #include "uart.h" 
.................... /* 
....................  * uart.h 
....................  * 
....................  *  Created on: Mar 23, 2017 
....................  *      Author: asaf 
....................  */ 
....................  
.................... #ifndef UART_H_ 
.................... #define UART_H_ 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... void uart_init(); 
.................... void uart_disable(); 
.................... uint8_t uart_get_byte_blocking(); 
.................... uint8_t uart_get_byte_nonblocking(uint8_t *dst); 
.................... void uart_send(void* buffer, uint8_t size); 
.................... void uart_clear_errors(); 
....................  
.................... #endif /* UART_H_ */ 
....................  
.................... #include "message.h" 
.................... /* 
....................  * message.h 
....................  * 
....................  *  Created on: Mar 23, 2017 
....................  *      Author: asaf 
....................  */ 
....................  
.................... #ifndef MESSAGE_H_ 
.................... #define MESSAGE_H_ 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include "calibration.h" 
.................... #ifndef CALIBRATION_H_ 
.................... #define CALIBRATION_H_ 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdbool.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                          stdbool.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard boolean definitions                                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __STDBOOL_H__ 
.................... #define __STDBOOL_H__ 
....................  
.................... //remove TRUE and FALSE added by CCS's device .h file 
.................... #if defined(TRUE) 
.................... #undef TRUE 
.................... #endif 
.................... #if defined(FALSE) 
.................... #undef FALSE 
.................... #endif 
....................  
.................... typedef int1   bool; 
.................... #define true   1 
.................... #define false  0 
.................... #define __bool_true_false_are_defined  1 
....................  
.................... #endif 
....................  
....................  
.................... #define CALIBRATION_AREA_START 0x4000 
.................... #define CALIBRATION_AREA_END 0x4FFF 
....................  
.................... typedef enum { 
....................   CALIBRATION_TABLE_PARAMS = 0, 
....................   CALIBRATION_TABLE_PA_GAINS_1 = 1, 
....................   CALIBRATION_TABLE_PA_GAINS_2 = 2, 
....................   CALIBRATION_TABLE_MAX = 3 
.................... } calibration_table_id_t; 
....................  
.................... typedef enum { 
....................   PARAM_CAL_TBL_VERSION = 0, 
....................   PARAM_SERIAL_NUM = 1, 
....................   PARAM_TEMP_MULT = 2, 
....................   PARAM_FWD_MULT = 3, 
....................   PARAM_REV_MULT = 4, 
....................   PARAM_INP_PWR_MULT = 5, 
....................   PARAM_PWR_CURRENT_MULT = 6, 
....................   PARAM_PRE_AMP_MULT = 7, 
....................   PARAM_ISENSE_PA1_MULT = 8, 
....................   PARAM_ISENSE_PA2_MULT = 9, 
....................   PARAM_BOOT_WAIT_TIME_USEC = 10, 
....................   PARAM_TX_ON_TIMING_USEC = 11, 
....................   PARAM_TX_OFF_TIMING_USEC = 12, 
....................   PARAM_PA_ON_TIMING_USEC = 13, 
....................   PARAM_PA_OFF_TIMING_USEC = 14, 
....................   PARAM_ANT_SEL_TIMING_USEC = 15, 
....................   PARAM_FWD_SAMP_TIMING_USEC = 16, 
....................   PARAM_REV_SAMP_TIMING_USEC = 17, 
....................   PARAM_INP_PWR_SAMP_TIMING_USEC = 18, 
.................... } calibration_param_t; 
....................  
.................... #define CALIBRATION_TABLE_INDEX_MAX 32 
....................  
.................... void get_calibration_table_data(calibration_table_id_t table_id, void* table_data); 
.................... void set_calibration_table_data(calibration_table_id_t table_id, void* table_data); 
.................... #INLINE 
.................... uint16_t get_calibration_param(calibration_table_id_t table, uint8_t index); 
.................... void set_calibration_param(calibration_table_id_t table, uint8_t index, uint16_t value); 
....................  
.................... #endif /* CALIBRATION_H_ */ 
....................  
....................  
.................... enum { 
....................   NUM_ADC_SAMPLES = 4, 
.................... }; 
....................  
.................... enum { 
....................   OP_CONTROL_MESSAGE = 0x00, 
....................   OP_VERSION_REQUEST_MESSAGE = 0x02, 
....................   OP_CHANGE_MODE_MESSAGE = 0x03, 
....................   OP_SET_CALIBRATION_TABLE_MESSAGE = 0x04, 
....................   OP_GET_CALIBRATION_TABLE_MESSAGE = 0x05, 
....................   OP_SET_DATA_LINE_MESSAGE = 0x06, 
....................   OP_GET_DATA_LINE_MESSAGE = 0x07, 
....................   OP_FINISH_UPDATE_PROCESS_MESSAGE = 0x08, 
....................   OP_BIT_STATUS_REQUEST_MESSAGE = 0x09, 
.................... }; 
....................  
.................... enum { 
....................   OP_ACK_RESPONSE = 0x80, 
....................   OP_SF_STATUS_RESPONSE = 0x81, 
....................   OP_VERSION_RESPONSE = 0x82, 
....................   OP_GET_CALIBRATION_TABLE_RESPONSE = 0x85, 
....................   OP_SET_DATA_LINE_RESPONSE = 0x86, 
....................   OP_GET_DATA_LINE_RESPONSE = 0x87, 
....................   OP_BIT_STATUS_RESPONSE = 0x89, 
.................... }; 
....................  
.................... typedef enum { 
....................   MODE_OPERATIONAL = 0, 
....................   MODE_TECHNICIAN = 1, 
....................   MODE_MAINTENANCE = 2, 
.................... } software_mode_t; 
....................  
.................... enum { 
....................   CALIBRATION_TABLE_TEMP = 0, 
....................   CALIBRATION_TABLE_FWD = 1, 
....................   CALIBRATION_TABLE_REV = 2, 
....................   CALIBRATION_TABLE_INP = 3, 
....................   CALIBRATION_TABLE_CURRENT = 4, 
....................   CALIBRATION_TABLE_PA_BIAS = 5, 
....................   CALIBRATION_TABLE_TIMING = 6, 
....................   CALIBRATION_TABLE_GENERAL = 7, 
.................... }; 
....................  
.................... enum { 
....................   PROGRAMMING_STATUS_OK = 0, 
....................   PROGRAMMING_STATUS_ERROR = 1, 
.................... }; 
....................  
.................... typedef struct message_t { 
....................   uint8_t opcode; 
....................   uint8_t payload[]; /* this will include the payload and the crc */ 
.................... } message_t; 
....................  
.................... typedef struct generic_response_t { 
....................   uint8_t opcode; 
.................... } generic_response_t; 
....................  
.................... /* message payloads*/ 
....................  
.................... typedef struct control_bits_t { 
....................   uint8_t tx_on : 1; 
....................   uint8_t pa_gain : 3; 
....................   uint8_t tx_ant : 1; 
....................   uint8_t amplifier_operation_frequency : 1; 
....................   uint8_t reset : 1; 
....................   uint8_t dont_change : 1; 
.................... } control_bits_t; 
....................  
.................... typedef struct control_message_payload_t { 
....................   control_bits_t bits; 
....................   uint16_t control_identifier; 
.................... } control_message_payload_t; 
....................  
.................... typedef struct change_mode_message_payload_t { 
....................   uint8_t mode; 
.................... } change_mode_message_payload_t; 
....................  
....................  
.................... typedef struct set_calibration_table_message_payload_t { 
....................   uint8_t table_id; 
....................   uint16_t params[CALIBRATION_TABLE_INDEX_MAX]; 
.................... } set_calibration_table_message_payload_t; 
....................  
.................... typedef struct get_calibration_table_message_payload_t { 
....................   uint8_t table_id; 
.................... } get_calibration_table_message_payload_t; 
....................  
.................... typedef struct set_data_line_payload_t { 
....................   uint32_t address; 
....................   uint8_t data[64]; 
.................... } set_data_line_payload_t; 
....................  
.................... typedef struct get_data_line_payload_t { 
....................   uint32_t address; 
.................... } get_data_line_payload_t; 
....................  
.................... /* responses */ 
....................  
.................... typedef struct ack_response_t { 
....................   generic_response_t generic; 
.................... } ack_response_t; 
....................  
.................... typedef struct sf_status_response_t { 
....................   generic_response_t generic; 
....................   control_bits_t last_control_bits; 
....................   uint16_t tti_counter; 
....................   uint16_t control_identifier; 
....................   uint16_t fwd_power_values[NUM_ADC_SAMPLES]; 
....................   uint16_t reverse_power_values[NUM_ADC_SAMPLES]; 
....................   uint16_t input_power_values[NUM_ADC_SAMPLES]; 
....................   uint16_t pre_amp_power_values[NUM_ADC_SAMPLES]; 
....................   uint16_t temperature; 
....................   uint16_t power_amplifier_current; 
.................... } sf_status_response_t; 
....................  
.................... typedef struct bit_status_response_t { 
....................   generic_response_t generic; 
....................   control_bits_t last_control_bits; 
....................   uint16_t tti_counter; 
....................   uint8_t mode; 
.................... } bit_status_response_t; 
....................  
.................... typedef struct version_response_t { 
....................   generic_response_t generic; 
....................   uint8_t day; 
....................   uint8_t month; 
....................   uint16_t year; 
....................   uint8_t major; 
....................   uint8_t minor; 
....................   uint16_t serial_number; 
.................... } version_response_t; 
....................  
.................... typedef struct calibration_table_response_t { 
....................   generic_response_t generic; 
....................   uint8_t table_id; 
....................   uint16_t params[CALIBRATION_TABLE_INDEX_MAX]; 
.................... } calibration_table_response_t; 
....................  
.................... typedef struct set_data_line_response_t { 
....................   generic_response_t generic; 
....................   uint32_t address; 
....................   uint8_t status; 
.................... } set_data_line_response_t; 
....................  
.................... typedef struct get_data_line_response_t { 
....................   generic_response_t generic; 
....................   uint32_t address; 
....................   uint8_t data[64]; 
.................... } get_data_line_response_t; 
....................  
.................... #endif /* MESSAGE_H_ */ 
....................  
.................... #include "rfc1662.h" 
.................... /* 
....................  * rfc1662.h 
....................  * 
....................  *  Created on: 09/01/2011 
....................  *      Author: asafe 
....................  */ 
....................  
.................... #ifndef __RFC1662_H__ 
.................... #define __RFC1662_H__ 
....................  
.................... #define CHAR_FLAG 0x7E 
.................... #define CHAR_FLAG_XORED 0x5E 
.................... #define CHAR_ESCAPE 0x7D 
.................... #define CHAR_ESCAPE_XORED 0x5D 
....................  
.................... int rfc1662_unpack(unsigned char *data, int len, unsigned char *dest); 
.................... int rfc1662_pack(unsigned char *data, int dataLen, unsigned char *dest); 
....................  
.................... #endif /* __RFC1662_H__ */ 
....................  
.................... #include "timer.h" 
.................... #ifndef INCLUDE_TIMER_H_ 
.................... #define INCLUDE_TIMER_H_ 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdbool.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                          stdbool.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard boolean definitions                                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __STDBOOL_H__ 
.................... #define __STDBOOL_H__ 
....................  
.................... //remove TRUE and FALSE added by CCS's device .h file 
.................... #if defined(TRUE) 
.................... #undef TRUE 
.................... #endif 
.................... #if defined(FALSE) 
.................... #undef FALSE 
.................... #endif 
....................  
.................... typedef int1   bool; 
.................... #define true   1 
.................... #define false  0 
.................... #define __bool_true_false_are_defined  1 
....................  
.................... #endif 
....................  
....................  
.................... typedef void (*timer_func)(void* arg); 
....................  
.................... typedef struct { 
....................   //bool triggred; 
....................   uint32_t expTime; 
....................   void *arg; 
....................   timer_func func; 
.................... } timer_task_t; 
....................  
.................... #INLINE 
.................... uint32_t timer_get_us_count(); 
.................... bool timer_registerTask(uint32_t expTime, timer_func func, void *arg); 
.................... void timer_yield(); 
....................  
.................... #endif /* INCLUDE_TIMER_H_ */ 
....................  
.................... #include "message_handlers.h" 
.................... /* 
....................  * message_handlers.h 
....................  * 
....................  *  Created on: Mar 26, 2017 
....................  *      Author: asaf 
....................  */ 
....................  
.................... #ifndef MESSAGE_HANDLERS_H_ 
.................... #define MESSAGE_HANDLERS_H_ 
....................  
.................... void init_message_handlers(); 
.................... void process_message(uint8_t* message, uint16_t length); 
.................... #INLINE 
.................... void perform_last_control_message(); 
.................... void control_handle_timer(); 
.................... void samp_if_needed(); 
....................  
.................... #endif /* MESSAGE_HANDLERS_H_ */ 
....................  
....................  
.................... static uint8_t rfcBuff[MSG_MAX_MESSAGE_LEN * 2 + 2]; 
....................  
.................... void comm_init() { 
....................   /* init the comm port */ 
....................   uart_init(); 
*
0C68:  BRA    0C54
.................... } 
0C6A:  GOTO   0702 (RETURN)
....................  
.................... /* this function receives a message from the host 
....................  * the function will block until a message arrives */ 
.................... bool comm_receive_message(void* buffer, uint16_t* size) { 
*
0E4A:  MOVLB  3
0E4C:  BCF    x91.0
0E4E:  CLRF   x92
....................   bool handleMessage = false; 
....................   int buffIdx = 0; 
....................  
....................   do { 
....................     uint8_t c; 
....................     if(!uart_get_byte_nonblocking(&c)) { 
0E50:  MOVLW  03
0E52:  MOVWF  x96
0E54:  MOVLW  93
0E56:  MOVWF  x95
0E58:  MOVLB  0
0E5A:  BRA    0C9C
0E5C:  MOVF   01,F
0E5E:  BNZ   0E62
.................... //      samp_if_needed(); 
....................       continue; 
0E60:  BRA    0EA2
....................     } 
....................     rfcBuff[buffIdx] = c; 
0E62:  CLRF   03
0E64:  MOVLB  3
0E66:  MOVF   x92,W
0E68:  ADDLW  20
0E6A:  MOVWF  FE9
0E6C:  MOVLW  00
0E6E:  ADDWFC 03,W
0E70:  MOVWF  FEA
0E72:  MOVFF  393,FEF
.................... //    rfcBuff[buffIdx] = uart_get_byte_blocking(); 
....................     if(rfcBuff[buffIdx] != CHAR_FLAG) { 
0E76:  CLRF   03
0E78:  MOVF   x92,W
0E7A:  ADDLW  20
0E7C:  MOVWF  FE9
0E7E:  MOVLW  00
0E80:  ADDWFC 03,W
0E82:  MOVWF  FEA
0E84:  MOVF   FEF,W
0E86:  SUBLW  7E
0E88:  BZ    0E96
....................     	buffIdx++; 
0E8A:  INCF   x92,F
....................       if(buffIdx == MSG_MAX_MESSAGE_LEN * 2 + 2) { 
0E8C:  MOVF   x92,W
0E8E:  SUBLW  A2
0E90:  BNZ   0E94
....................         buffIdx = 0; 
0E92:  CLRF   x92
....................       } 
....................   	} else { 
0E94:  BRA    0EA2
....................   		if(buffIdx >= 2) { 
0E96:  MOVF   x92,W
0E98:  SUBLW  01
0E9A:  BC    0EA0
....................   			handleMessage = true; 
0E9C:  BSF    x91.0
....................   		} else { 
0E9E:  BRA    0EA2
....................   			// discard small messages 
....................   			buffIdx = 0; 
0EA0:  CLRF   x92
....................   		} 
....................   	} 
....................   } while(!handleMessage); 
0EA2:  MOVLB  3
0EA4:  BTFSS  x91.0
0EA6:  BRA    0E50
....................  
....................   if(handleMessage) { 
0EA8:  BTFSS  x91.0
0EAA:  BRA    0EEA
....................     int len = rfc1662_unpack(rfcBuff, buffIdx, buffer); 
0EAC:  CLRF   x96
0EAE:  MOVLW  20
0EB0:  MOVWF  x95
0EB2:  MOVFF  392,397
0EB6:  MOVFF  38E,399
0EBA:  MOVFF  38D,398
0EBE:  MOVLB  0
0EC0:  BRA    0DD6
0EC2:  MOVFF  01,394
....................     if(len == -1) 
0EC6:  MOVLB  3
0EC8:  MOVF   x94,W
0ECA:  SUBLW  FF
0ECC:  BNZ   0ED4
....................     { 
....................       /* the packet fcs was wrong don't accept it */ 
....................       return false; 
0ECE:  MOVLW  00
0ED0:  MOVWF  01
0ED2:  BRA    0EEE
....................   	} 
....................     *size = len; 
0ED4:  MOVFF  38F,FE9
0ED8:  MOVFF  390,FEA
0EDC:  CLRF   FEC
0EDE:  MOVF   FED,F
0EE0:  MOVFF  394,FEF
....................     return true; 
0EE4:  MOVLW  01
0EE6:  MOVWF  01
0EE8:  BRA    0EEE
....................   } 
....................  
....................   return false; 
0EEA:  MOVLW  00
0EEC:  MOVWF  01
.................... } 
0EEE:  MOVLB  0
0EF0:  GOTO   1698 (RETURN)
....................  
.................... void comm_send_message(void* buffer, uint16_t size) { 
*
0F9A:  MOVFF  3DE,3E4
0F9E:  MOVFF  3DD,3E3
0FA2:  MOVFF  3DF,3E5
0FA6:  MOVLB  3
0FA8:  CLRF   xE7
0FAA:  MOVLW  20
0FAC:  MOVWF  xE6
0FAE:  MOVLB  0
0FB0:  BRA    1042
0FB2:  MOVLB  3
0FB4:  CLRF   xE2
0FB6:  MOVFF  01,3E1
....................   uint16_t rfc_len = rfc1662_pack(buffer, size, rfcBuff); 
....................   uart_send(rfcBuff, rfc_len); 
0FBA:  CLRF   xE4
0FBC:  MOVLW  20
0FBE:  MOVWF  xE3
0FC0:  MOVFF  3E1,3E5
0FC4:  MOVLB  0
0FC6:  BRA    0F80
.................... } 
0FC8:  RETURN 0
....................  
.................... /* 
....................  * rfc1662.c 
....................  * 
....................  *  Created on: 09/01/2011 
....................  *      Author: asafe 
....................  */ 
....................  
.................... #include "BA1474.h" 
.................... #include <18F45K22.h> 
.................... //////// Standard Header file for the PIC18F45K22 device //////////////// 
.................... #device PIC18F45K22 
.................... #list 
....................  
.................... #device adc=10 
.................... #device pass_strings=in_ram 
....................  
.................... #define LOADER_END 0x1FFF 
.................... #include <boot.h> 
.................... #undef LOADER_END 
.................... #define FLASH_SIZE getenv("FLASH_ERASE_SIZE") 
.................... #define LOADER_END   0x1FFF 
.................... #define LOADER_SIZE  0x3FF 
....................  
.................... #ifndef _bootloader 
.................... #build(reset=LOADER_END+1, interrupt=LOADER_END+9) 
....................  
.................... /* when in operational software, keep out of the bootloader sections */ 
.................... #org 0, 0xfff {} 
.................... #org 0x1000, 0x1ffe {} 
....................  
.................... #else 
....................  
.................... /* when in the bootloader, keep out of the operational sections */ 
.................... #org 0x2000, 0x7ffe {} 
....................  
.................... #endif 
....................  
....................  
.................... #FUSES NOWDT                   //No Watch Dog Timer 
.................... #FUSES WDT128                  //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES INTRC_IO                //Internal RC Osc, no CLKOUT 
.................... #FUSES NOBROWNOUT              //No brownout reset 
.................... #FUSES WDT_SW                  //No Watch Dog Timer, enabled in Software 
.................... #FUSES NOLVP                   //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOPUT 
.................... #FUSES NOXINST                 //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(clock=64000000) 
.................... #use rs232(baud=921600,xmit=PIN_C6,rcv=PIN_C7,ERRORS) 
.................... #USE TIMER(TIMER=1,TICK=1us,BITS=32,NOISR) 
.................... #use spi(DO=PIN_A4, CLK=PIN_A3, ENABLE=PIN_A2, ENABLE_ACTIVE=0, DATA_HOLD=20, BITS=16) 
....................  
.................... #opt 9 
....................  
.................... #use fast_io(a) 
.................... #use fast_io(b) 
.................... #use fast_io(c) 
.................... #use fast_io(d) 
.................... #use fast_io(e) 
....................  
.................... #define safe_write_program_memory(address, pointer, size) \ 
....................   do { disable_interrupts(GLOBAL); write_program_memory(address, pointer, size); enable_interrupts(GLOBAL); delay_us(1000); } while (0) 
....................  
....................  
.................... #include "rfc1662.h" 
.................... /* 
....................  * rfc1662.h 
....................  * 
....................  *  Created on: 09/01/2011 
....................  *      Author: asafe 
....................  */ 
....................  
.................... #ifndef __RFC1662_H__ 
.................... #define __RFC1662_H__ 
....................  
.................... #define CHAR_FLAG 0x7E 
.................... #define CHAR_FLAG_XORED 0x5E 
.................... #define CHAR_ESCAPE 0x7D 
.................... #define CHAR_ESCAPE_XORED 0x5D 
....................  
.................... int rfc1662_unpack(unsigned char *data, int len, unsigned char *dest); 
.................... int rfc1662_pack(unsigned char *data, int dataLen, unsigned char *dest); 
....................  
.................... #endif /* __RFC1662_H__ */ 
....................  
.................... #include "crc8.h" 
.................... #ifndef __CRC8__ 
.................... #define __CRC8__ 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... uint8_t crc8(uint8_t* buffer, uint16_t size); 
....................  
.................... #endif 
....................  
....................  
.................... static int replaceFlagAndEscape(unsigned char *data, unsigned char *dest, int datalen) 
.................... { 
*
1142:  MOVLB  3
1144:  CLRF   xF2
1146:  CLRF   xF3
.................... 	int datai=0; 
.................... 	int desti=0; 
.................... 	for(datai=0;datai<datalen;datai++) 
1148:  CLRF   xF2
114A:  MOVF   xF1,W
114C:  SUBWF  xF2,W
114E:  BC    11FE
.................... 	{ 
.................... 		if(data[datai] == CHAR_FLAG) 
1150:  CLRF   03
1152:  MOVF   xF2,W
1154:  ADDWF  xED,W
1156:  MOVWF  FE9
1158:  MOVF   xEE,W
115A:  ADDWFC 03,W
115C:  MOVWF  FEA
115E:  MOVF   FEF,W
1160:  SUBLW  7E
1162:  BNZ   118E
.................... 		{ 
.................... 			dest[desti++] = CHAR_ESCAPE; 
1164:  MOVF   xF3,W
1166:  INCF   xF3,F
1168:  CLRF   03
116A:  ADDWF  xEF,W
116C:  MOVWF  FE9
116E:  MOVF   xF0,W
1170:  ADDWFC 03,W
1172:  MOVWF  FEA
1174:  MOVLW  7D
1176:  MOVWF  FEF
.................... 			dest[desti++] = CHAR_FLAG_XORED; 
1178:  MOVF   xF3,W
117A:  INCF   xF3,F
117C:  CLRF   03
117E:  ADDWF  xEF,W
1180:  MOVWF  FE9
1182:  MOVF   xF0,W
1184:  ADDWFC 03,W
1186:  MOVWF  FEA
1188:  MOVLW  5E
118A:  MOVWF  FEF
.................... 		} 
.................... 		else if(data[datai] == CHAR_ESCAPE) 
118C:  BRA    11FA
118E:  CLRF   03
1190:  MOVF   xF2,W
1192:  ADDWF  xED,W
1194:  MOVWF  FE9
1196:  MOVF   xEE,W
1198:  ADDWFC 03,W
119A:  MOVWF  FEA
119C:  MOVF   FEF,W
119E:  SUBLW  7D
11A0:  BNZ   11CC
.................... 		{ 
.................... 			dest[desti++] = CHAR_ESCAPE; 
11A2:  MOVF   xF3,W
11A4:  INCF   xF3,F
11A6:  CLRF   03
11A8:  ADDWF  xEF,W
11AA:  MOVWF  FE9
11AC:  MOVF   xF0,W
11AE:  ADDWFC 03,W
11B0:  MOVWF  FEA
11B2:  MOVLW  7D
11B4:  MOVWF  FEF
.................... 			dest[desti++] = CHAR_ESCAPE_XORED; 
11B6:  MOVF   xF3,W
11B8:  INCF   xF3,F
11BA:  CLRF   03
11BC:  ADDWF  xEF,W
11BE:  MOVWF  FE9
11C0:  MOVF   xF0,W
11C2:  ADDWFC 03,W
11C4:  MOVWF  FEA
11C6:  MOVLW  5D
11C8:  MOVWF  FEF
.................... 		} 
.................... 		else 
11CA:  BRA    11FA
.................... 		{ 
.................... 			dest[desti++] = data[datai]; 
11CC:  MOVF   xF3,W
11CE:  INCF   xF3,F
11D0:  CLRF   03
11D2:  ADDWF  xEF,W
11D4:  MOVWF  xF4
11D6:  MOVF   xF0,W
11D8:  ADDWFC 03,W
11DA:  MOVWF  xF5
11DC:  CLRF   03
11DE:  MOVF   xF2,W
11E0:  ADDWF  xED,W
11E2:  MOVWF  FE9
11E4:  MOVF   xEE,W
11E6:  ADDWFC 03,W
11E8:  MOVWF  FEA
11EA:  MOVFF  FEF,3F6
11EE:  MOVFF  3F5,FEA
11F2:  MOVFF  3F4,FE9
11F6:  MOVFF  3F6,FEF
.................... 		} 
.................... 	} 
11FA:  INCF   xF2,F
11FC:  BRA    114A
.................... 	return desti; //return the size of the new data string 
11FE:  MOVFF  3F3,01
.................... } 
1202:  MOVLB  0
1204:  RETURN 0
....................  
.................... static int restoreFlagAndEscape(unsigned char *data, unsigned char *dest, int datalen) 
.................... { 
*
0CD2:  MOVLB  3
0CD4:  CLRF   xA2
0CD6:  CLRF   xA3
.................... 	int datai=0; 
.................... 	int desti=0; 
.................... 	for(datai=0;datai<datalen;datai++) 
0CD8:  CLRF   xA2
0CDA:  MOVF   xA1,W
0CDC:  SUBWF  xA2,W
0CDE:  BC    0D7E
.................... 	{ 
.................... 		if(data[datai] == CHAR_ESCAPE) 
0CE0:  CLRF   03
0CE2:  MOVF   xA2,W
0CE4:  ADDWF  x9D,W
0CE6:  MOVWF  FE9
0CE8:  MOVF   x9E,W
0CEA:  ADDWFC 03,W
0CEC:  MOVWF  FEA
0CEE:  MOVF   FEF,W
0CF0:  SUBLW  7D
0CF2:  BNZ   0D4A
.................... 		{ 
.................... 			datai++; 
0CF4:  INCF   xA2,F
.................... 			if(data[datai] == CHAR_FLAG_XORED) 
0CF6:  CLRF   03
0CF8:  MOVF   xA2,W
0CFA:  ADDWF  x9D,W
0CFC:  MOVWF  FE9
0CFE:  MOVF   x9E,W
0D00:  ADDWFC 03,W
0D02:  MOVWF  FEA
0D04:  MOVF   FEF,W
0D06:  SUBLW  5E
0D08:  BNZ   0D20
.................... 			{ 
.................... 				dest[desti++] = CHAR_FLAG; 
0D0A:  MOVF   xA3,W
0D0C:  INCF   xA3,F
0D0E:  CLRF   03
0D10:  ADDWF  x9F,W
0D12:  MOVWF  FE9
0D14:  MOVF   xA0,W
0D16:  ADDWFC 03,W
0D18:  MOVWF  FEA
0D1A:  MOVLW  7E
0D1C:  MOVWF  FEF
.................... 			} 
.................... 			else if(data[datai] == CHAR_ESCAPE_XORED) 
0D1E:  BRA    0D48
0D20:  CLRF   03
0D22:  MOVF   xA2,W
0D24:  ADDWF  x9D,W
0D26:  MOVWF  FE9
0D28:  MOVF   x9E,W
0D2A:  ADDWFC 03,W
0D2C:  MOVWF  FEA
0D2E:  MOVF   FEF,W
0D30:  SUBLW  5D
0D32:  BNZ   0D48
.................... 			{ 
.................... 				dest[desti++] = CHAR_ESCAPE; 
0D34:  MOVF   xA3,W
0D36:  INCF   xA3,F
0D38:  CLRF   03
0D3A:  ADDWF  x9F,W
0D3C:  MOVWF  FE9
0D3E:  MOVF   xA0,W
0D40:  ADDWFC 03,W
0D42:  MOVWF  FEA
0D44:  MOVLW  7D
0D46:  MOVWF  FEF
.................... 			} 
.................... 			else 
.................... 			{ 
.................... 				//count this as an error on the stream! 
.................... 			} 
.................... 		} 
.................... 		else 
0D48:  BRA    0D7A
.................... 		{ 
.................... 			dest[desti++] = data[datai]; 
0D4A:  MOVF   xA3,W
0D4C:  INCF   xA3,F
0D4E:  CLRF   03
0D50:  ADDWF  x9F,W
0D52:  MOVWF  01
0D54:  MOVF   xA0,W
0D56:  ADDWFC 03,F
0D58:  MOVFF  03,3A5
0D5C:  CLRF   03
0D5E:  MOVF   xA2,W
0D60:  ADDWF  x9D,W
0D62:  MOVWF  FE9
0D64:  MOVF   x9E,W
0D66:  ADDWFC 03,W
0D68:  MOVWF  FEA
0D6A:  MOVFF  FEF,3A6
0D6E:  MOVFF  3A5,FEA
0D72:  MOVFF  01,FE9
0D76:  MOVFF  3A6,FEF
.................... 		} 
.................... 	} 
0D7A:  INCF   xA2,F
0D7C:  BRA    0CDA
.................... 	return desti; //return the size of the new data string 
0D7E:  MOVFF  3A3,01
.................... } 
0D82:  MOVLB  0
0D84:  GOTO   0DF2 (RETURN)
....................  
.................... //this function encapsulate the data with all the information needed 
.................... //to be sent via the rfc1662 protocol (PPP with HDLC like framing) 
.................... //this function should be called for sending data through the rs422 link 
.................... //dataLen should be the datalength only! 
....................  
.................... int rfc1662_pack(unsigned char *data, int dataLen, unsigned char *dest) 
.................... { 
*
1042:  MOVLB  3
1044:  CLRF   xE8
1046:  CLRF   xE9
1048:  MOVFF  3E4,3EC
104C:  MOVFF  3E3,3EB
1050:  CLRF   xEE
1052:  MOVFF  3E5,3ED
1056:  MOVLB  0
1058:  RCALL  0D88
105A:  MOVFF  01,3EA
.................... 	int changed_data_size = 0; 
.................... 	int changed_crc_size = 0; 
.................... 	//calc crc and add it to the end of the data 
.................... 	uint8_t crc = crc8(data, dataLen); 
.................... 	//replace escape and flag 
.................... 	changed_data_size = replaceFlagAndEscape(data, &dest[1], dataLen); 
105E:  MOVLW  01
1060:  MOVLB  3
1062:  ADDWF  xE6,W
1064:  MOVWF  xEB
1066:  MOVLW  00
1068:  ADDWFC xE7,W
106A:  MOVWF  xEC
106C:  MOVFF  3E4,3EE
1070:  MOVFF  3E3,3ED
1074:  MOVFF  3EC,3F0
1078:  MOVFF  3EB,3EF
107C:  MOVFF  3E5,3F1
1080:  MOVLB  0
1082:  RCALL  1142
1084:  MOVFF  01,3E8
.................... 	changed_crc_size = replaceFlagAndEscape(&crc, &dest[changed_data_size+1], sizeof(crc)); 
1088:  MOVLW  01
108A:  MOVLB  3
108C:  ADDWF  xE8,W
108E:  CLRF   03
1090:  ADDWF  xE6,W
1092:  MOVWF  xEB
1094:  MOVF   xE7,W
1096:  ADDWFC 03,W
1098:  MOVWF  xEC
109A:  MOVLW  03
109C:  MOVWF  xEE
109E:  MOVLW  EA
10A0:  MOVWF  xED
10A2:  MOVFF  3EC,3F0
10A6:  MOVFF  3EB,3EF
10AA:  MOVLW  01
10AC:  MOVWF  xF1
10AE:  MOVLB  0
10B0:  RCALL  1142
10B2:  MOVFF  01,3E9
.................... 	//add the flags 
.................... 	dest[0] = CHAR_FLAG; 
10B6:  MOVLB  3
10B8:  MOVFF  3E6,FE9
10BC:  MOVFF  3E7,FEA
10C0:  MOVLW  7E
10C2:  MOVWF  FEF
.................... 	dest[changed_data_size+changed_crc_size+1] = CHAR_FLAG; 
10C4:  MOVF   xE9,W
10C6:  ADDWF  xE8,W
10C8:  ADDLW  01
10CA:  CLRF   03
10CC:  ADDWF  xE6,W
10CE:  MOVWF  FE9
10D0:  MOVF   xE7,W
10D2:  ADDWFC 03,W
10D4:  MOVWF  FEA
10D6:  MOVLW  7E
10D8:  MOVWF  FEF
....................  
.................... 	// returns the size of dest 
.................... 	return changed_data_size+changed_crc_size+2; 
10DA:  MOVF   xE9,W
10DC:  ADDWF  xE8,W
10DE:  ADDLW  02
10E0:  MOVWF  01
.................... } 
10E2:  MOVLB  0
10E4:  GOTO   0FB2 (RETURN)
....................  
....................  
.................... int rfc1662_unpack(unsigned char *data, int len, unsigned char *dest) 
.................... { 
*
0DD6:  MOVLB  3
0DD8:  CLRF   x9A
.................... 	int restored_data_size = 0; 
.................... 	//the received data is received without the start and end FLAGS 
.................... 	restored_data_size = restoreFlagAndEscape(data, dest, len); 
0DDA:  MOVFF  396,39E
0DDE:  MOVFF  395,39D
0DE2:  MOVFF  399,3A0
0DE6:  MOVFF  398,39F
0DEA:  MOVFF  397,3A1
0DEE:  MOVLB  0
0DF0:  BRA    0CD2
0DF2:  MOVFF  01,39A
....................  
.................... 	if (restored_data_size < 1) 
0DF6:  MOVLB  3
0DF8:  MOVF   x9A,F
0DFA:  BNZ   0E02
.................... 		return -1; 
0DFC:  MOVLW  FF
0DFE:  MOVWF  01
0E00:  BRA    0E44
....................  
.................... 	uint8_t calculated_crc = crc8(dest, restored_data_size - 1); 
.................... 	uint8_t message_crc = dest[restored_data_size - 1]; 
0E02:  MOVLW  01
0E04:  SUBWF  x9A,W
0E06:  MOVWF  x9D
0E08:  MOVFF  399,3EC
0E0C:  MOVFF  398,3EB
0E10:  CLRF   xEE
0E12:  MOVWF  xED
0E14:  MOVLB  0
0E16:  RCALL  0D88
0E18:  MOVFF  01,39B
0E1C:  MOVLW  01
0E1E:  MOVLB  3
0E20:  SUBWF  x9A,W
0E22:  CLRF   03
0E24:  ADDWF  x98,W
0E26:  MOVWF  FE9
0E28:  MOVF   x99,W
0E2A:  ADDWFC 03,W
0E2C:  MOVWF  FEA
0E2E:  MOVFF  FEF,39C
.................... 	if (calculated_crc == message_crc) { 
0E32:  MOVF   x9C,W
0E34:  SUBWF  x9B,W
0E36:  BNZ   0E40
.................... 		//crc is correct 
.................... 		//return the size of the new data 
.................... 		return restored_data_size-1; //we get dsti+1 at the end and the 1 crc 
0E38:  MOVLW  01
0E3A:  SUBWF  x9A,W
0E3C:  MOVWF  01
0E3E:  BRA    0E44
.................... 	} 
.................... 	 
.................... 	return -1; 
0E40:  MOVLW  FF
0E42:  MOVWF  01
.................... } 
0E44:  MOVLB  0
0E46:  GOTO   0EC2 (RETURN)
....................  
.................... /* 
....................  * uart.c 
....................  * 
....................  *  Created on: Mar 23, 2017 
....................  *      Author: asaf 
....................  */ 
.................... #include "BA1474.h" 
.................... #include <18F45K22.h> 
.................... //////// Standard Header file for the PIC18F45K22 device //////////////// 
.................... #device PIC18F45K22 
.................... #list 
....................  
.................... #device adc=10 
.................... #device pass_strings=in_ram 
....................  
.................... #define LOADER_END 0x1FFF 
.................... #include <boot.h> 
.................... #undef LOADER_END 
.................... #define FLASH_SIZE getenv("FLASH_ERASE_SIZE") 
.................... #define LOADER_END   0x1FFF 
.................... #define LOADER_SIZE  0x3FF 
....................  
.................... #ifndef _bootloader 
.................... #build(reset=LOADER_END+1, interrupt=LOADER_END+9) 
....................  
.................... /* when in operational software, keep out of the bootloader sections */ 
.................... #org 0, 0xfff {} 
.................... #org 0x1000, 0x1ffe {} 
....................  
.................... #else 
....................  
.................... /* when in the bootloader, keep out of the operational sections */ 
.................... #org 0x2000, 0x7ffe {} 
....................  
.................... #endif 
....................  
....................  
.................... #FUSES NOWDT                   //No Watch Dog Timer 
.................... #FUSES WDT128                  //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES INTRC_IO                //Internal RC Osc, no CLKOUT 
.................... #FUSES NOBROWNOUT              //No brownout reset 
.................... #FUSES WDT_SW                  //No Watch Dog Timer, enabled in Software 
.................... #FUSES NOLVP                   //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOPUT 
.................... #FUSES NOXINST                 //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(clock=64000000) 
.................... #use rs232(baud=921600,xmit=PIN_C6,rcv=PIN_C7,ERRORS) 
.................... #USE TIMER(TIMER=1,TICK=1us,BITS=32,NOISR) 
.................... #use spi(DO=PIN_A4, CLK=PIN_A3, ENABLE=PIN_A2, ENABLE_ACTIVE=0, DATA_HOLD=20, BITS=16) 
....................  
.................... #opt 9 
....................  
.................... #use fast_io(a) 
.................... #use fast_io(b) 
.................... #use fast_io(c) 
.................... #use fast_io(d) 
.................... #use fast_io(e) 
....................  
.................... #define safe_write_program_memory(address, pointer, size) \ 
....................   do { disable_interrupts(GLOBAL); write_program_memory(address, pointer, size); enable_interrupts(GLOBAL); delay_us(1000); } while (0) 
....................  
....................  
.................... #include "PIC18F45K22_registers.h" 
.................... #byte TOSU = 0xFFF 
.................... #word TOS = 0xFFE 
.................... #byte STKPTR = 0xFFC 
.................... #bit    STKPTR0 = STKPTR.0 
.................... #bit    STKPTR1 = STKPTR.1 
.................... #bit    STKPTR2 = STKPTR.2 
.................... #bit    STKPTR3 = STKPTR.3 
.................... #bit    STKPTR4 = STKPTR.4 
.................... #bit    STKUNF = STKPTR.6 
.................... #bit    STKFUL = STKPTR.7 
.................... #byte PCLATU = 0xFFB 
.................... #byte PCLATH = 0xFFA 
.................... #byte PCL = 0xFF9 
.................... #byte TBLPTRU = 0xFF8 
.................... #word TBLPTR = 0xFF7 
.................... #byte TABLAT = 0xFF5 
.................... #word PROD = 0xFF4 
.................... #byte INTCON = 0xFF2 
.................... #bit    RBIF = INTCON.0 
.................... #bit    INT0IF = INTCON.1 
.................... #bit    TMR0IF = INTCON.2 
.................... #bit    RBIE = INTCON.3 
.................... #bit    INT0IE = INTCON.4 
.................... #bit    TMR0IE = INTCON.5 
.................... #bit    PEIE_GIEL = INTCON.6 
.................... #bit    GIE_GIEH = INTCON.7 
.................... #byte INTCON2 = 0xFF1 
.................... #bit    RBIP = INTCON2.0 
.................... #bit    TMR0IP = INTCON2.2 
.................... #bit    INTEDG2 = INTCON2.4 
.................... #bit    INTEDG1 = INTCON2.5 
.................... #bit    INTEDG0 = INTCON2.6 
.................... #bit    RBPU = INTCON2.7 
.................... #byte INTCON3 = 0xFF0 
.................... #bit    INT1IF = INTCON3.0 
.................... #bit    INT2IF = INTCON3.1 
.................... #bit    INT1IE = INTCON3.3 
.................... #bit    INT2IE = INTCON3.4 
.................... #bit    INT1IP = INTCON3.6 
.................... #bit    INT2IP = INTCON3.7 
.................... #byte INDF0 = 0xFEF 
.................... #byte POSTINC0 = 0xFEE 
.................... #byte POSTDEC0 = 0xFED 
.................... #byte PREINC0 = 0xFEC 
.................... #byte PLUSW0 = 0xFEB 
.................... #word FSR0 = 0xFEA 
.................... #byte WREG = 0xFE8 
.................... #byte INDF1 = 0xFE7 
.................... #byte POSTINC1 = 0xFE6 
.................... #byte POSTDEC1 = 0xFE5 
.................... #byte PREINC1 = 0xFE4 
.................... #byte PLUSW1 = 0xFE3 
.................... #word FSR1 = 0xFE2 
.................... #byte BSR = 0xFE0 
.................... #byte INDF2 = 0xFDF 
.................... #byte POSTINC2 = 0xFDE 
.................... #byte POSTDEC2 = 0xFDD 
.................... #byte PREINC2 = 0xFDC 
.................... #byte PLUSW2 = 0xFDB 
.................... #word FSR2 = 0xFDA 
.................... #byte STATUS = 0xFD8 
.................... #bit    C = STATUS.0 
.................... #bit    DC = STATUS.1 
.................... #bit    Z = STATUS.2 
.................... #bit    OV = STATUS.3 
.................... #bit    N = STATUS.4 
.................... #word TMR0 = 0xFD7 
.................... #byte T0CON = 0xFD5 
.................... #bit    T0PS0 = T0CON.0 
.................... #bit    T0PS1 = T0CON.1 
.................... #bit    T0PS2 = T0CON.2 
.................... #bit    PSA = T0CON.3 
.................... #bit    T0SE = T0CON.4 
.................... #bit    T0CS = T0CON.5 
.................... #bit    T08BIT = T0CON.6 
.................... #bit    TMR0ON = T0CON.7 
.................... #byte OSCCON = 0xFD3 
.................... #bit    SCS0 = OSCCON.0 
.................... #bit    SCS1 = OSCCON.1 
.................... #bit    HFIOFS = OSCCON.2 
.................... #bit    OSTS = OSCCON.3 
.................... #bit    IRCF0 = OSCCON.4 
.................... #bit    IRCF1 = OSCCON.5 
.................... #bit    IRCF2 = OSCCON.6 
.................... #bit    IDLEN = OSCCON.7 
.................... #byte OSCCON2 = 0xFD2 
.................... #bit    LFIOFS = OSCCON2.0 
.................... #bit    MFIOFS = OSCCON2.1 
.................... #bit    PRISD = OSCCON2.2 
.................... #bit    SOSCGO = OSCCON2.3 
.................... #bit    MFIOSEL = OSCCON2.4 
.................... #bit    SOSCRUN = OSCCON2.6 
.................... #bit    PLLRDY = OSCCON2.7 
.................... #byte WDTCON = 0xFD1 
.................... #bit    SWDTEN = WDTCON.0 
.................... #byte RCON = 0xFD0 
.................... #bit    BOR = RCON.0 
.................... #bit    POR = RCON.1 
.................... #bit    PD = RCON.2 
.................... #bit    TO = RCON.3 
.................... #bit    RI = RCON.4 
.................... #bit    SBOREN = RCON.6 
.................... #bit    IPEN = RCON.7 
.................... #word TMR1 = 0xFCF 
.................... #byte T1CON = 0xFCD 
.................... #bit    TMR1ON = T1CON.0 
.................... #bit    T1RD16 = T1CON.1 
.................... #bit    T1SYNC = T1CON.2 
.................... #bit    T1SOSCEN = T1CON.3 
.................... #bit    T1CKPS0 = T1CON.4 
.................... #bit    T1CKPS1 = T1CON.5 
.................... #bit    TMR1CS0 = T1CON.6 
.................... #bit    TMR1CS1 = T1CON.7 
.................... #byte T1GCON = 0xFCC 
.................... #bit    T1GSS0 = T1GCON.0 
.................... #bit    T1GSS1 = T1GCON.1 
.................... #bit    T1GVAL = T1GCON.2 
.................... #bit    T1GGO = T1GCON.3 
.................... #bit    T1GSPM = T1GCON.4 
.................... #bit    T1GTM = T1GCON.5 
.................... #bit    T1GPOL = T1GCON.6 
.................... #bit    TMR1GE = T1GCON.7 
.................... #byte SSP1CON3 = 0xFCB 
.................... #bit    DHEN = SSP1CON3.0 
.................... #bit    AHEN = SSP1CON3.1 
.................... #bit    SBCDE = SSP1CON3.2 
.................... #bit    SDAHT = SSP1CON3.3 
.................... #bit    BOEN = SSP1CON3.4 
.................... #bit    SCIE = SSP1CON3.5 
.................... #bit    PCIE = SSP1CON3.6 
.................... #bit    ACKTIM = SSP1CON3.7 
.................... #byte SSP1MSK = 0xFCA 
.................... #byte SSP1BUF = 0xFC9 
.................... #byte SSP1ADD = 0xFC8 
.................... #byte SSP1STAT = 0xFC7 
.................... #bit    BF = SSP1STAT.0 
.................... #bit    UA = SSP1STAT.1 
.................... #bit    R = SSP1STAT.2 
.................... #bit    S = SSP1STAT.3 
.................... #bit    P = SSP1STAT.4 
.................... #bit    D = SSP1STAT.5 
.................... #bit    CKE = SSP1STAT.6 
.................... #bit    SMP = SSP1STAT.7 
.................... #byte SSP1CON1 = 0xFC6 
.................... #bit    SSPM0 = SSP1CON1.0 
.................... #bit    SSPM1 = SSP1CON1.1 
.................... #bit    SSPM2 = SSP1CON1.2 
.................... #bit    SSPM3 = SSP1CON1.3 
.................... #bit    CKP = SSP1CON1.4 
.................... #bit    SSPEN = SSP1CON1.5 
.................... #bit    SSPOV = SSP1CON1.6 
.................... #bit    WCOL = SSP1CON1.7 
.................... #byte SSP1CON2 = 0xFC5 
.................... #bit    SEN = SSP1CON2.0 
.................... #bit    RSEN = SSP1CON2.1 
.................... #bit    PEN = SSP1CON2.2 
.................... #bit    RCEN = SSP1CON2.3 
.................... #bit    ACKEN = SSP1CON2.4 
.................... #bit    ACKDT = SSP1CON2.5 
.................... #bit    ACKSTAT = SSP1CON2.6 
.................... #bit    GCEN = SSP1CON2.7 
.................... #word ADRES = 0xFC4 
.................... #byte ADCON0 = 0xFC2 
.................... #bit    ADON = ADCON0.0 
.................... #bit    GO = ADCON0.1 
.................... #bit    CHS0 = ADCON0.2 
.................... #bit    CHS1 = ADCON0.3 
.................... #bit    CHS2 = ADCON0.4 
.................... #bit    CHS3 = ADCON0.5 
.................... #bit    CHS4 = ADCON0.6 
.................... #byte ADCON1 = 0xFC1 
.................... #bit    NVCFG0 = ADCON1.0 
.................... #bit    NVCFG1 = ADCON1.1 
.................... #bit    PVCFG0 = ADCON1.2 
.................... #bit    PVCFG1 = ADCON1.3 
.................... #bit    TRIGSEL = ADCON1.7 
.................... #byte ADCON2 = 0xFC0 
.................... #bit    ADCS0 = ADCON2.0 
.................... #bit    ADCS1 = ADCON2.1 
.................... #bit    ADCS2 = ADCON2.2 
.................... #bit    ACQT0 = ADCON2.3 
.................... #bit    ACQT1 = ADCON2.4 
.................... #bit    ACQT2 = ADCON2.5 
.................... #bit    ADFM = ADCON2.7 
.................... #word CCPR1 = 0xFBF 
.................... #byte CCP1CON = 0xFBD 
.................... #bit    CCP1M0 = CCP1CON.0 
.................... #bit    CCP1M1 = CCP1CON.1 
.................... #bit    CCP1M2 = CCP1CON.2 
.................... #bit    CCP1M3 = CCP1CON.3 
.................... #bit    DC1B0 = CCP1CON.4 
.................... #bit    DC1B1 = CCP1CON.5 
.................... #bit    P1M0 = CCP1CON.6 
.................... #bit    P1M1 = CCP1CON.7 
.................... #byte TMR2 = 0xFBC 
.................... #byte PR2 = 0xFBB 
.................... #byte T2CON = 0xFBA 
.................... #bit    T2CKPS0 = T2CON.0 
.................... #bit    T2CKPS1 = T2CON.1 
.................... #bit    TMR2ON = T2CON.2 
.................... #bit    T2OUTPS0 = T2CON.3 
.................... #bit    T2OUTPS1 = T2CON.4 
.................... #bit    T2OUTPS2 = T2CON.5 
.................... #bit    T2OUTPS3 = T2CON.6 
.................... #byte PSTR1CON = 0xFB9 
.................... #bit    STR1A = PSTR1CON.0 
.................... #bit    STR1B = PSTR1CON.1 
.................... #bit    STR1C = PSTR1CON.2 
.................... #bit    STR1D = PSTR1CON.3 
.................... #bit    STR1SYNC = PSTR1CON.4 
.................... #byte BAUDCON1 = 0xFB8 
.................... #bit    ABDEN = BAUDCON1.0 
.................... #bit    WUE = BAUDCON1.1 
.................... #bit    BRG16 = BAUDCON1.3 
.................... #bit    CKTXP = BAUDCON1.4 
.................... #bit    DTRXP = BAUDCON1.5 
.................... #bit    RCIDL = BAUDCON1.6 
.................... #bit    ABDOVF = BAUDCON1.7 
.................... #byte PWM1CON = 0xFB7 
.................... #bit    P1DC0 = PWM1CON.0 
.................... #bit    P1DC1 = PWM1CON.1 
.................... #bit    P1DC2 = PWM1CON.2 
.................... #bit    P1DC3 = PWM1CON.3 
.................... #bit    P1DC4 = PWM1CON.4 
.................... #bit    P1DC5 = PWM1CON.5 
.................... #bit    P1DC6 = PWM1CON.6 
.................... #bit    P1RSEN = PWM1CON.7 
.................... #byte ECCP1AS = 0xFB6 
.................... #bit    P1SSBD0 = ECCP1AS.0 
.................... #bit    P1SSBD1 = ECCP1AS.1 
.................... #bit    P1SSAC0 = ECCP1AS.2 
.................... #bit    P1SSAC1 = ECCP1AS.3 
.................... #bit    CCP1AS0 = ECCP1AS.4 
.................... #bit    CCP1AS1 = ECCP1AS.5 
.................... #bit    CCP1AS2 = ECCP1AS.6 
.................... #bit    CCP1ASE = ECCP1AS.7 
.................... #byte T3GCON = 0xFB4 
.................... #bit    T3GSS0 = T3GCON.0 
.................... #bit    T3GSS1 = T3GCON.1 
.................... #bit    T3GVAL = T3GCON.2 
.................... #bit    T3GGO = T3GCON.3 
.................... #bit    T3GSPM = T3GCON.4 
.................... #bit    T3GTM = T3GCON.5 
.................... #bit    T3GPOL = T3GCON.6 
.................... #bit    TMR3GE = T3GCON.7 
.................... #word TMR3 = 0xFB3 
.................... #byte T3CON = 0xFB1 
.................... #bit    TMR3ON = T3CON.0 
.................... #bit    T3RD16 = T3CON.1 
.................... #bit    T3SYNC = T3CON.2 
.................... #bit    T3SOSCEN = T3CON.3 
.................... #bit    T3CKPS0 = T3CON.4 
.................... #bit    T3CKPS1 = T3CON.5 
.................... #bit    TMR3CS0 = T3CON.6 
.................... #bit    TMR3CS1 = T3CON.7 
.................... #byte SPBRGH1 = 0xFB0 
.................... #byte SPBRG1 = 0xFAF 
.................... #byte RCREG1 = 0xFAE 
.................... #byte TXREG1 = 0xFAD 
.................... #byte TXSTA1 = 0xFAC 
.................... #bit    TX9D = TXSTA1.0 
.................... #bit    TRMT = TXSTA1.1 
.................... #bit    BRGH = TXSTA1.2 
.................... #bit    SENDB = TXSTA1.3 
.................... #bit    SYNC = TXSTA1.4 
.................... #bit    TXEN = TXSTA1.5 
.................... #bit    TX9 = TXSTA1.6 
.................... #bit    CSRC = TXSTA1.7 
.................... #byte RCSTA1 = 0xFAB 
.................... #bit    RX9D = RCSTA1.0 
.................... #bit    OERR = RCSTA1.1 
.................... #bit    FERR = RCSTA1.2 
.................... #bit    ADDEN = RCSTA1.3 
.................... #bit    CREN = RCSTA1.4 
.................... #bit    SREN = RCSTA1.5 
.................... #bit    RX9 = RCSTA1.6 
.................... #bit    SPEN = RCSTA1.7 
.................... #byte EEADR = 0xFA9 
.................... #byte EEDATA = 0xFA8 
.................... #byte EECON2 = 0xFA7 
.................... #byte EECON1 = 0xFA6 
.................... #bit    RD = EECON1.0 
.................... #bit    WR = EECON1.1 
.................... #bit    WREN = EECON1.2 
.................... #bit    WRERR = EECON1.3 
.................... #bit    FREE = EECON1.4 
.................... #bit    CFGS = EECON1.6 
.................... #bit    EEPGD = EECON1.7 
.................... #byte IPR3 = 0xFA5 
.................... #bit    TMR1GIP = IPR3.0 
.................... #bit    TMR3GIP = IPR3.1 
.................... #bit    TMR5GIP = IPR3.2 
.................... #bit    CTMUIP = IPR3.3 
.................... #bit    TX2IP = IPR3.4 
.................... #bit    RC2IP = IPR3.5 
.................... #bit    BCL2IP = IPR3.6 
.................... #bit    SSP2IP = IPR3.7 
.................... #byte PIR3 = 0xFA4 
.................... #bit    TMR1GIF = PIR3.0 
.................... #bit    TMR3GIF = PIR3.1 
.................... #bit    TMR5GIF = PIR3.2 
.................... #bit    CTMUIF = PIR3.3 
.................... #bit    TX2IF = PIR3.4 
.................... #bit    RC2IF = PIR3.5 
.................... #bit    BCL2IF = PIR3.6 
.................... #bit    SSP2IF = PIR3.7 
.................... #byte PIE3 = 0xFA3 
.................... #bit    TMR1GIE = PIE3.0 
.................... #bit    TMR3GIE = PIE3.1 
.................... #bit    TMR5GIE = PIE3.2 
.................... #bit    CTMUIE = PIE3.3 
.................... #bit    TX2IE = PIE3.4 
.................... #bit    RC2IE = PIE3.5 
.................... #bit    BCL2IE = PIE3.6 
.................... #bit    SSP2IE = PIE3.7 
.................... #byte IPR2 = 0xFA2 
.................... #bit    CCP2IP = IPR2.0 
.................... #bit    TMR3IP = IPR2.1 
.................... #bit    HLVDIP = IPR2.2 
.................... #bit    BCL1IP = IPR2.3 
.................... #bit    EEIP = IPR2.4 
.................... #bit    C2IP = IPR2.5 
.................... #bit    C1IP = IPR2.6 
.................... #bit    OSCFIP = IPR2.7 
.................... #byte PIR2 = 0xFA1 
.................... #bit    CCP2IF = PIR2.0 
.................... #bit    TMR3IF = PIR2.1 
.................... #bit    HLVDIF = PIR2.2 
.................... #bit    BCL1IF = PIR2.3 
.................... #bit    EEIF = PIR2.4 
.................... #bit    C2IF = PIR2.5 
.................... #bit    C1IF = PIR2.6 
.................... #bit    OSCFIF = PIR2.7 
.................... #byte PIE2 = 0xFA0 
.................... #bit    CCP2IE = PIE2.0 
.................... #bit    TMR3IE = PIE2.1 
.................... #bit    HLVDIE = PIE2.2 
.................... #bit    BCL1IE = PIE2.3 
.................... #bit    EEIE = PIE2.4 
.................... #bit    C2IE = PIE2.5 
.................... #bit    C1IE = PIE2.6 
.................... #bit    OSCFIE = PIE2.7 
.................... #byte IPR1 = 0xF9F 
.................... #bit    TMR1IP = IPR1.0 
.................... #bit    TMR2IP = IPR1.1 
.................... #bit    CCP1IP = IPR1.2 
.................... #bit    SSP1IP = IPR1.3 
.................... #bit    TX1IP = IPR1.4 
.................... #bit    RC1IP = IPR1.5 
.................... #bit    ADIP = IPR1.6 
.................... #byte PIR1 = 0xF9E 
.................... #bit    TMR1IF = PIR1.0 
.................... #bit    TMR2IF = PIR1.1 
.................... #bit    CCP1IF = PIR1.2 
.................... #bit    SSP1IF = PIR1.3 
.................... #bit    TX1IF = PIR1.4 
.................... #bit    RC1IF = PIR1.5 
.................... #bit    ADIF = PIR1.6 
.................... #byte PIE1 = 0xF9D 
.................... #bit    TMR1IE = PIE1.0 
.................... #bit    TMR2IE = PIE1.1 
.................... #bit    CCP1IE = PIE1.2 
.................... #bit    SSP1IE = PIE1.3 
.................... #bit    TX1IE = PIE1.4 
.................... #bit    RC1IE = PIE1.5 
.................... #bit    ADIE = PIE1.6 
.................... #byte HLVDCON = 0xF9C 
.................... #bit    HLVDL0 = HLVDCON.0 
.................... #bit    HLVDL1 = HLVDCON.1 
.................... #bit    HLVDL2 = HLVDCON.2 
.................... #bit    HLVDL3 = HLVDCON.3 
.................... #bit    HLVDEN = HLVDCON.4 
.................... #bit    IRVST = HLVDCON.5 
.................... #bit    BGVST = HLVDCON.6 
.................... #bit    VDIRMAG = HLVDCON.7 
.................... #byte OSCTUNE = 0xF9B 
.................... #bit    TUN0 = OSCTUNE.0 
.................... #bit    TUN1 = OSCTUNE.1 
.................... #bit    TUN2 = OSCTUNE.2 
.................... #bit    TUN3 = OSCTUNE.3 
.................... #bit    TUN4 = OSCTUNE.4 
.................... #bit    TUN5 = OSCTUNE.5 
.................... #bit    PLLEN = OSCTUNE.6 
.................... #bit    INTSRC = OSCTUNE.7 
.................... #byte TRISE = 0xF96 
.................... #bit    TRISE0 = TRISE.0 
.................... #bit    TRISE1 = TRISE.1 
.................... #bit    TRISE2 = TRISE.2 
.................... #bit    WPUE3 = TRISE.7 
.................... #byte TRISD = 0xF95 
.................... #byte TRISC = 0xF94 
.................... #byte TRISB = 0xF93 
.................... #byte TRISA = 0xF92 
.................... #byte LATE = 0xF8D 
.................... #byte LATD = 0xF8C 
.................... #byte LATC = 0xF8B 
.................... #byte LATB = 0xF8A 
.................... #byte LATA = 0xF89 
.................... #byte PORTE = 0xF84 
.................... #byte PORTD = 0xF83 
.................... #byte PORTC = 0xF82 
.................... #byte PORTB = 0xF81 
.................... #byte PORTA = 0xF80 
.................... #byte IPR5 = 0xF7F 
.................... #bit    TMR4IP = IPR5.0 
.................... #bit    TMR5IP = IPR5.1 
.................... #bit    TMR6IP = IPR5.2 
.................... #byte PIR5 = 0xF7E 
.................... #bit    TMR4IF = PIR5.0 
.................... #bit    TMR5IF = PIR5.1 
.................... #bit    TMR6IF = PIR5.2 
.................... #byte PIE5 = 0xF7D 
.................... #bit    TMR4IE = PIE5.0 
.................... #bit    TMR5IE = PIE5.1 
.................... #bit    TMR6IE = PIE5.2 
.................... #byte IPR4 = 0xF7C 
.................... #bit    CCP3IP = IPR4.0 
.................... #bit    CCP4IP = IPR4.1 
.................... #bit    CCP5IP = IPR4.2 
.................... #byte PIR4 = 0xF7B 
.................... #bit    CCP3IF = PIR4.0 
.................... #bit    CCP4IF = PIR4.1 
.................... #bit    CCP5IF = PIR4.2 
.................... #byte PIE4 = 0xF7A 
.................... #bit    CCP3IE = PIE4.0 
.................... #bit    CCP4IE = PIE4.1 
.................... #bit    CCP5IE = PIE4.2 
.................... #byte CM1CON0 = 0xF79 
.................... #bit    C1CH0 = CM1CON0.0 
.................... #bit    C1CH1 = CM1CON0.1 
.................... #bit    C1R = CM1CON0.2 
.................... #bit    C1SP = CM1CON0.3 
.................... #bit    C1POL = CM1CON0.4 
.................... #bit    C1OE = CM1CON0.5 
.................... //#bit    C1OUT = CM1CON0.6 
.................... #bit    C1ON = CM1CON0.7 
.................... #byte CM2CON0 = 0xF78 
.................... #bit    C2CH0 = CM2CON0.0 
.................... #bit    C2CH1 = CM2CON0.1 
.................... #bit    C2R = CM2CON0.2 
.................... #bit    C2SP = CM2CON0.3 
.................... #bit    C2POL = CM2CON0.4 
.................... #bit    C2OE = CM2CON0.5 
.................... //#bit    C2OUT = CM2CON0.6 
.................... #bit    C2ON = CM2CON0.7 
.................... #byte CM2CON1 = 0xF77 
.................... #bit    C2SYNC = CM2CON1.0 
.................... #bit    C1SYNC = CM2CON1.1 
.................... #bit    C2HYS = CM2CON1.2 
.................... #bit    C1HYS = CM2CON1.3 
.................... #bit    C2RSEL = CM2CON1.4 
.................... #bit    C1RSEL = CM2CON1.5 
.................... #bit    MC2OUT = CM2CON1.6 
.................... #bit    MC1OUT = CM2CON1.7 
.................... #byte SPBRGH2 = 0xF76 
.................... #byte SPBRG2 = 0xF75 
.................... #byte RCREG2 = 0xF74 
.................... #byte TXREG2 = 0xF73 
.................... #byte TXSTA2 = 0xF72 
.................... #bit    U2TX9D = TXSTA2.0 
.................... #bit    U2TRMT = TXSTA2.1 
.................... #bit    U2BRGH = TXSTA2.2 
.................... #bit    U2SENDB = TXSTA2.3 
.................... #bit    U2SYNC = TXSTA2.4 
.................... #bit    U2TXEN = TXSTA2.5 
.................... #bit    U2TX9 = TXSTA2.6 
.................... #bit    U2CSRC = TXSTA2.7 
.................... #byte RCSTA2 = 0xF71 
.................... #bit    U1RX9D = RCSTA2.0 
.................... #bit    U1OERR = RCSTA2.1 
.................... #bit    U1FERR = RCSTA2.2 
.................... #bit    U1ADDEN = RCSTA2.3 
.................... #bit    U1CREN = RCSTA2.4 
.................... #bit    U1SREN = RCSTA2.5 
.................... #bit    U1RX9 = RCSTA2.6 
.................... #bit    U1SPEN = RCSTA2.7 
.................... #byte BAUDCON2 = 0xF70 
.................... #bit    U1ABDEN = BAUDCON2.0 
.................... #bit    U1WUE = BAUDCON2.1 
.................... #bit    U1BRG16 = BAUDCON2.3 
.................... #bit    U1CKTXP = BAUDCON2.4 
.................... #bit    U1DTRXP = BAUDCON2.5 
.................... #bit    U1RCIDL = BAUDCON2.6 
.................... #bit    U1ABDOVF = BAUDCON2.7 
.................... #byte SSP2BUF = 0xF6F 
.................... #byte SSP2ADD = 0xF6E 
.................... #byte SSP2STAT = 0xF6D 
.................... #bit    SP2BF = SSP2STAT.0 
.................... #bit    SP2UA = SSP2STAT.1 
.................... #bit    SP2R = SSP2STAT.2 
.................... #bit    SP2S = SSP2STAT.3 
.................... #bit    SP2P = SSP2STAT.4 
.................... #bit    SP2D = SSP2STAT.5 
.................... #bit    SP2CKE = SSP2STAT.6 
.................... #bit    SP2SMP = SSP2STAT.7 
.................... #byte SSP2CON1 = 0xF6C 
.................... #bit    SP2SSPM0 = SSP2CON1.0 
.................... #bit    SP2SSPM1 = SSP2CON1.1 
.................... #bit    SP2SSPM2 = SSP2CON1.2 
.................... #bit    SP2SSPM3 = SSP2CON1.3 
.................... #bit    SP2CKP = SSP2CON1.4 
.................... #bit    SP2SSPEN = SSP2CON1.5 
.................... #bit    SP2SSPOV = SSP2CON1.6 
.................... #bit    SP2WCOL = SSP2CON1.7 
.................... #byte SSP2CON2 = 0xF6B 
.................... #bit    SP2SEN = SSP2CON2.0 
.................... #bit    SP2RSEN = SSP2CON2.1 
.................... #bit    SP2PEN = SSP2CON2.2 
.................... #bit    SP2RCEN = SSP2CON2.3 
.................... #bit    SP2ACKEN = SSP2CON2.4 
.................... #bit    SP2ACKDT = SSP2CON2.5 
.................... #bit    SP2ACKSTAT = SSP2CON2.6 
.................... #bit    SP2GCEN = SSP2CON2.7 
.................... #byte SSP2MSK = 0xF6A 
.................... #byte SSP2CON3 = 0xF69 
.................... #bit    SP2DHEN = SSP2CON3.0 
.................... #bit    SP2AHEN = SSP2CON3.1 
.................... #bit    SP2SBCDE = SSP2CON3.2 
.................... #bit    SP2SDAHT = SSP2CON3.3 
.................... #bit    SP2BOEN = SSP2CON3.4 
.................... #bit    SP2SCIE = SSP2CON3.5 
.................... #bit    SP2PCIE = SSP2CON3.6 
.................... #bit    SP2ACKTIM = SSP2CON3.7 
.................... #word CCPR2 = 0xF68 
.................... #byte CCP2CON = 0xF66 
.................... #bit    CCP2M0 = CCP2CON.0 
.................... #bit    CCP2M1 = CCP2CON.1 
.................... #bit    CCP2M2 = CCP2CON.2 
.................... #bit    CCP2M3 = CCP2CON.3 
.................... #bit    CCP2DC2B0 = CCP2CON.4 
.................... #bit    CCP2DC2B1 = CCP2CON.5 
.................... #bit    CCP2P2M0 = CCP2CON.6 
.................... #bit    CCP2P2M1 = CCP2CON.7 
.................... #byte PWM2CON = 0xF65 
.................... #bit    P2DC0 = PWM2CON.0 
.................... #bit    P2DC1 = PWM2CON.1 
.................... #bit    P2DC2 = PWM2CON.2 
.................... #bit    P2DC3 = PWM2CON.3 
.................... #bit    P2DC4 = PWM2CON.4 
.................... #bit    P2DC5 = PWM2CON.5 
.................... #bit    P2DC6 = PWM2CON.6 
.................... #bit    P2RSEN = PWM2CON.7 
.................... #byte ECCP2AS = 0xF64 
.................... #bit    P2SSBD0 = ECCP2AS.0 
.................... #bit    P2SSBD1 = ECCP2AS.1 
.................... #bit    P2SSAC0 = ECCP2AS.2 
.................... #bit    P2SSAC1 = ECCP2AS.3 
.................... #bit    CCP2AS0 = ECCP2AS.4 
.................... #bit    CCP2AS1 = ECCP2AS.5 
.................... #bit    CCP2AS2 = ECCP2AS.6 
.................... #bit    CCP2ASE = ECCP2AS.7 
.................... #byte PSTR2CON = 0xF63 
.................... #bit    STR2A = PSTR2CON.0 
.................... #bit    STR2B = PSTR2CON.1 
.................... #bit    STR2C = PSTR2CON.2 
.................... #bit    STR2D = PSTR2CON.3 
.................... #bit    STR2SYNC = PSTR2CON.4 
.................... #byte IOCB = 0xF62 
.................... #bit    IOCB4 = IOCB.4 
.................... #bit    IOCB5 = IOCB.5 
.................... #bit    IOCB6 = IOCB.6 
.................... #bit    IOCB7 = IOCB.7 
.................... #byte WPUB = 0xF61 
.................... #byte SLRCON = 0xF60 
.................... #bit    SLRA = SLRCON.0 
.................... #bit    SLRB = SLRCON.1 
.................... #bit    SLRC = SLRCON.2 
.................... #bit    SLRD = SLRCON.3 
.................... #bit    SLRE = SLRCON.4 
.................... #word CCPR3 = 0xF5F 
.................... #byte CCP3CON = 0xF5D 
.................... #bit    CCP3M0 = CCP3CON.0 
.................... #bit    CCP3M1 = CCP3CON.1 
.................... #bit    CCP3M2 = CCP3CON.2 
.................... #bit    CCP3M3 = CCP3CON.3 
.................... #bit    CCP3DC3B0 = CCP3CON.4 
.................... #bit    CCP3DC3B1 = CCP3CON.5 
.................... #bit    CCP3P3M0 = CCP3CON.6 
.................... #bit    CCP3P3M1 = CCP3CON.7 
.................... #byte PWM3CON = 0xF5C 
.................... #bit    P3DC0 = PWM3CON.0 
.................... #bit    P3DC1 = PWM3CON.1 
.................... #bit    P3DC2 = PWM3CON.2 
.................... #bit    P3DC3 = PWM3CON.3 
.................... #bit    P3DC4 = PWM3CON.4 
.................... #bit    P3DC5 = PWM3CON.5 
.................... #bit    P3DC6 = PWM3CON.6 
.................... #bit    P3RSEN = PWM3CON.7 
.................... #byte ECCP3AS = 0xF5B 
.................... #bit    P3SSBD0 = ECCP3AS.0 
.................... #bit    P3SSBD1 = ECCP3AS.1 
.................... #bit    P3SSAC0 = ECCP3AS.2 
.................... #bit    P3SSAC1 = ECCP3AS.3 
.................... #bit    CCP3AS0 = ECCP3AS.4 
.................... #bit    CCP3AS1 = ECCP3AS.5 
.................... #bit    CCP3AS2 = ECCP3AS.6 
.................... #bit    CCP3ASE = ECCP3AS.7 
.................... #byte PSTR3CON = 0xF5A 
.................... #bit    STR3A = PSTR3CON.0 
.................... #bit    STR3B = PSTR3CON.1 
.................... #bit    STR3C = PSTR3CON.2 
.................... #bit    STR3D = PSTR3CON.3 
.................... #bit    STR3SYNC = PSTR3CON.4 
.................... #word CCPR4 = 0xF59 
.................... #byte CCP4CON = 0xF57 
.................... #bit    CCP4M0 = CCP4CON.0 
.................... #bit    CCP4M1 = CCP4CON.1 
.................... #bit    CCP4M2 = CCP4CON.2 
.................... #bit    CCP4M3 = CCP4CON.3 
.................... #bit    CCP4DC4B0 = CCP4CON.4 
.................... #bit    CCP4DC4B1 = CCP4CON.5 
.................... #word CCPR5 = 0xF56 
.................... #byte CCP5CON = 0xF54 
.................... #bit    CCP5M0 = CCP5CON.0 
.................... #bit    CCP5M1 = CCP5CON.1 
.................... #bit    CCP5M2 = CCP5CON.2 
.................... #bit    CCP5M3 = CCP5CON.3 
.................... #bit    CCP5DC5B0 = CCP5CON.4 
.................... #bit    CCP5DC5B1 = CCP5CON.5 
.................... #byte TMR4 = 0xF53 
.................... #byte PR4 = 0xF52 
.................... #byte T4CON = 0xF51 
.................... #bit    T4CKPS0 = T4CON.0 
.................... #bit    T4CKPS1 = T4CON.1 
.................... #bit    TMR4ON = T4CON.2 
.................... #bit    T4OUTPS0 = T4CON.3 
.................... #bit    T4OUTPS1 = T4CON.4 
.................... #bit    T4OUTPS2 = T4CON.5 
.................... #bit    T4OUTPS3 = T4CON.6 
.................... #word TMR5 = 0xF50 
.................... #byte T5CON = 0xF4E 
.................... #bit    TMR5ON = T5CON.0 
.................... #bit    T5RD16 = T5CON.1 
.................... #bit    T5SYNC = T5CON.2 
.................... #bit    T5SOSCEN = T5CON.3 
.................... #bit    T5CKPS0 = T5CON.4 
.................... #bit    T5CKPS1 = T5CON.5 
.................... #bit    TMR5CS0 = T5CON.6 
.................... #bit    TMR5CS1 = T5CON.7 
.................... #byte T5GCON = 0xF4D 
.................... #bit    T5GSS0 = T5GCON.0 
.................... #bit    T5GSS1 = T5GCON.1 
.................... #bit    T5GVAL = T5GCON.2 
.................... #bit    T5GGO = T5GCON.3 
.................... #bit    T5GSPM = T5GCON.4 
.................... #bit    T5GTM = T5GCON.5 
.................... #bit    T5GPOL = T5GCON.6 
.................... #bit    TMR5GE = T5GCON.7 
.................... #byte TMR6 = 0xF4C 
.................... #byte PR6 = 0xF4B 
.................... #byte T6CON = 0xF4A 
.................... #bit    T6CKPS0 = T6CON.0 
.................... #bit    T6CKPS1 = T6CON.1 
.................... #bit    TMR6ON = T6CON.2 
.................... #bit    T6OUTPS0 = T6CON.3 
.................... #bit    T6OUTPS1 = T6CON.4 
.................... #bit    T6OUTPS2 = T6CON.5 
.................... #bit    T6OUTPS3 = T6CON.6 
.................... #byte CCPTMRS0 = 0xF49 
.................... #bit    C1TSEL0 = CCPTMRS0.0 
.................... #bit    C1TSEL1 = CCPTMRS0.1 
.................... #bit    C2TSEL0 = CCPTMRS0.3 
.................... #bit    C2TSEL1 = CCPTMRS0.4 
.................... #bit    C3TSEL0 = CCPTMRS0.6 
.................... #bit    C3TSEL1 = CCPTMRS0.7 
.................... #byte CCPTMRS1 = 0xF48 
.................... #bit    C4TSEL0 = CCPTMRS1.0 
.................... #bit    C4TSEL1 = CCPTMRS1.1 
.................... #bit    C5TSEL0 = CCPTMRS1.2 
.................... #bit    C5TSEL1 = CCPTMRS1.3 
.................... #byte SRCON0 = 0xF47 
.................... #bit    SRPR = SRCON0.0 
.................... #bit    SRPS = SRCON0.1 
.................... #bit    SRNQEN = SRCON0.2 
.................... #bit    SRQEN = SRCON0.3 
.................... #bit    SRCLK0 = SRCON0.4 
.................... #bit    SRCLK1 = SRCON0.5 
.................... #bit    SRCLK2 = SRCON0.6 
.................... #bit    SRLEN = SRCON0.7 
.................... #byte SRCON1 = 0xF46 
.................... #bit    SRRC1E = SRCON1.0 
.................... #bit    SRRC2E = SRCON1.1 
.................... #bit    SRRCKE = SRCON1.2 
.................... #bit    SRRPE = SRCON1.3 
.................... #bit    SRSC1E = SRCON1.4 
.................... #bit    SRSC2E = SRCON1.5 
.................... #bit    SRSCKE = SRCON1.6 
.................... #bit    SRSPE = SRCON1.7 
.................... #word CTMUCON = 0xF45 
.................... #byte CTMUICON = 0xF43 
.................... #bit    IRNG0 = CTMUICON.0 
.................... #bit    IRNG1 = CTMUICON.1 
.................... #bit    ITRIM0 = CTMUICON.2 
.................... #bit    ITRIM1 = CTMUICON.3 
.................... #bit    ITRIM2 = CTMUICON.4 
.................... #bit    ITRIM3 = CTMUICON.5 
.................... #bit    ITRIM4 = CTMUICON.6 
.................... #bit    ITRIM5 = CTMUICON.7 
.................... #byte VREFCON0 = 0xF42 
.................... #bit    FVRS0 = VREFCON0.4 
.................... #bit    FVRS1 = VREFCON0.5 
.................... #bit    FVRST = VREFCON0.6 
.................... #bit    FVREN = VREFCON0.7 
.................... #byte VREFCON1 = 0xF41 
.................... #bit    DACNSS = VREFCON1.0 
.................... #bit    DACPSS0 = VREFCON1.2 
.................... #bit    DACPSS1 = VREFCON1.3 
.................... #bit    DACOE = VREFCON1.5 
.................... #bit    DACLPS = VREFCON1.6 
.................... #bit    DACEN = VREFCON1.7 
.................... #byte VREFCON2 = 0xF40 
.................... #byte PMD0 = 0xF3F 
.................... #bit    TMR1MD = PMD0.0 
.................... #bit    TMR2MD = PMD0.1 
.................... #bit    TMR3MD = PMD0.2 
.................... #bit    TMR4MD = PMD0.3 
.................... #bit    TMR5MD = PMD0.4 
.................... #bit    TMR6MD = PMD0.5 
.................... #bit    UART1MD = PMD0.6 
.................... #bit    UART2MD = PMD0.7 
.................... #byte PMD1 = 0xF3E 
.................... #bit    CCP1MD = PMD1.0 
.................... #bit    CCP2MD = PMD1.1 
.................... #bit    CCP3MD = PMD1.2 
.................... #bit    CCP4MD = PMD1.3 
.................... #bit    CCP5MD = PMD1.4 
.................... #bit    MSSP1MD = PMD1.6 
.................... #bit    MSSP2MD = PMD1.7 
.................... #byte PMD2 = 0xF3D 
.................... #bit    ADCMD = PMD2.0 
.................... #bit    CMP1MD = PMD2.1 
.................... #bit    CMP2MD = PMD2.2 
.................... #bit    CTMUMD = PMD2.3 
.................... #byte ANSELE = 0xF3C 
.................... #byte ANSELD = 0xF3B 
.................... #byte ANSELC = 0xF3A 
.................... #bit    ANSC2 = ANSELC.2 
.................... #bit    ANSC3 = ANSELC.3 
.................... #bit    ANSC4 = ANSELC.4 
.................... #bit    ANSC5 = ANSELC.5 
.................... #bit    ANSC6 = ANSELC.6 
.................... #bit    ANSC7 = ANSELC.7 
.................... #byte ANSELB = 0xF39 
.................... #byte ANSELA = 0xF38 
.................... #bit    ANSA0 = ANSELA.0 
.................... #bit    ANSA1 = ANSELA.1 
.................... #bit    ANSA2 = ANSELA.2 
.................... #bit    ANSA3 = ANSELA.3 
.................... #bit    ANSA5 = ANSELA.5 
....................  
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define MAX_UART_SIZE 180 
....................  
.................... static uint8_t rbuf[MAX_UART_SIZE]; 
.................... static uint8_t rbuf_wr_idx; 
.................... static uint8_t rbuf_rd_idx; 
....................  
.................... static uint8_t wbuf[MAX_UART_SIZE]; 
.................... static uint8_t wbuf_wr_idx; 
.................... static uint8_t wbuf_rd_idx; 
....................  
.................... void uart_clear_errors(); 
....................  
.................... void uart_init() { 
....................   rbuf_wr_idx = 0; 
*
0C54:  MOVLB  1
0C56:  CLRF   x76
....................   rbuf_rd_idx = 0; 
0C58:  CLRF   x77
....................   wbuf_wr_idx = 0; 
0C5A:  MOVLB  2
0C5C:  CLRF   x2C
....................   wbuf_rd_idx = 0; 
0C5E:  CLRF   x2D
....................   enable_interrupts(int_RDA); 
0C60:  BSF    F9D.5
.................... } 
0C62:  MOVLB  0
0C64:  GOTO   0C6A (RETURN)
....................  
.................... void uart_disable() { 
....................   disable_interrupts(int_RDA); 
....................   disable_interrupts(int_TBE); 
.................... } 
....................  
.................... static uint8_t get_next_byte() { 
*
0C6E:  MOVLB  1
0C70:  MOVF   x77,W
0C72:  INCF   x77,F
0C74:  CLRF   03
0C76:  ADDLW  C2
0C78:  MOVWF  FE9
0C7A:  MOVLW  00
0C7C:  ADDWFC 03,W
0C7E:  MOVWF  FEA
0C80:  MOVFF  FEF,399
0C84:  MOVLB  3
....................   uint8_t c = rbuf[rbuf_rd_idx++]; 
....................   if(rbuf_rd_idx >= MAX_UART_SIZE) { 
0C86:  MOVLB  1
0C88:  MOVF   x77,W
0C8A:  SUBLW  B3
0C8C:  BC    0C90
....................     rbuf_rd_idx = 0; 
0C8E:  CLRF   x77
....................   } 
....................   return c; 
0C90:  MOVLB  3
0C92:  MOVFF  399,01
.................... } 
0C96:  MOVLB  0
0C98:  GOTO   0CBA (RETURN)
....................  
.................... /* stupid implementation, overwrite old data... */ 
.................... static void push_bytes(uint8_t *src, uint16_t len) { 
*
1206:  MOVLW  B4
1208:  BSF    FD8.0
120A:  MOVLB  2
120C:  SUBFWB x2C,W
120E:  MOVLB  3
1210:  MOVWF  xEA
....................     int d = MAX_UART_SIZE - wbuf_wr_idx; 
....................     if(len > d) { 
1212:  MOVF   xE9,F
1214:  BNZ   121C
1216:  MOVF   xE8,W
1218:  SUBWF  xEA,W
121A:  BC    1296
....................       memcpy(wbuf + wbuf_wr_idx, src, d); 
121C:  MOVLW  78
121E:  MOVLB  2
1220:  ADDWF  x2C,W
1222:  MOVLB  3
1224:  MOVWF  xEB
1226:  MOVLW  01
1228:  MOVWF  xEC
122A:  BTFSC  FD8.0
122C:  INCF   xEC,F
122E:  MOVFF  3EC,FEA
1232:  MOVFF  3EB,FE9
1236:  MOVFF  3E7,FE2
123A:  MOVFF  3E6,FE1
123E:  MOVF   xEA,W
1240:  MOVWF  01
1242:  BZ    124C
1244:  MOVFF  FE6,FEE
1248:  DECFSZ 01,F
124A:  BRA    1244
....................       len -= d; 
124C:  MOVF   xEA,W
124E:  SUBWF  xE8,F
1250:  MOVLW  00
1252:  SUBWFB xE9,F
....................       memcpy(wbuf, src + d, len); 
1254:  MOVF   xEA,W
1256:  ADDWF  xE6,W
1258:  MOVWF  xEB
125A:  MOVLW  00
125C:  ADDWFC xE7,W
125E:  MOVWF  xEC
1260:  MOVLW  01
1262:  MOVWF  FEA
1264:  MOVLW  78
1266:  MOVWF  FE9
1268:  MOVFF  3EC,FE2
126C:  MOVFF  3EB,FE1
1270:  MOVFF  3E9,02
1274:  MOVFF  3E8,01
1278:  MOVF   01,F
127A:  BZ    1280
127C:  INCF   02,F
127E:  BRA    1284
1280:  MOVF   02,F
1282:  BZ    1290
1284:  MOVFF  FE6,FEE
1288:  DECFSZ 01,F
128A:  BRA    1284
128C:  DECFSZ 02,F
128E:  BRA    1284
....................       wbuf_wr_idx = len; 
1290:  MOVFF  3E8,22C
....................     } else { 
1294:  BRA    12DE
....................       memcpy(wbuf + wbuf_wr_idx, src, len); 
1296:  MOVLW  78
1298:  MOVLB  2
129A:  ADDWF  x2C,W
129C:  MOVLB  3
129E:  MOVWF  xEB
12A0:  MOVLW  01
12A2:  MOVWF  xEC
12A4:  BTFSC  FD8.0
12A6:  INCF   xEC,F
12A8:  MOVFF  3EC,FEA
12AC:  MOVFF  3EB,FE9
12B0:  MOVFF  3E7,FE2
12B4:  MOVFF  3E6,FE1
12B8:  MOVFF  3E9,02
12BC:  MOVFF  3E8,01
12C0:  MOVF   01,F
12C2:  BZ    12C8
12C4:  INCF   02,F
12C6:  BRA    12CC
12C8:  MOVF   02,F
12CA:  BZ    12D8
12CC:  MOVFF  FE6,FEE
12D0:  DECFSZ 01,F
12D2:  BRA    12CC
12D4:  DECFSZ 02,F
12D6:  BRA    12CC
....................       wbuf_wr_idx += len; 
12D8:  MOVF   xE8,W
12DA:  MOVLB  2
12DC:  ADDWF  x2C,F
....................     } 
....................     if(wbuf_wr_idx == MAX_UART_SIZE) { 
12DE:  MOVLB  2
12E0:  MOVF   x2C,W
12E2:  SUBLW  B4
12E4:  BNZ   12E8
.................... 		  wbuf_wr_idx = 0;     
12E6:  CLRF   x2C
.................... 	  }  
.................... } 
12E8:  MOVLB  0
12EA:  GOTO   0F94 (RETURN)
....................  
.................... uint8_t uart_get_byte_blocking() { 
....................   while(rbuf_wr_idx == rbuf_rd_idx) { 
.................... enable_interrupts(INT_EXT);  
.................... }; 
....................   return get_next_byte(); 
.................... } 
....................  
.................... uint8_t uart_get_byte_nonblocking(uint8_t *dst) { 
....................   if(rbuf_wr_idx == rbuf_rd_idx) { 
*
0C9C:  MOVLB  1
0C9E:  MOVF   x77,W
0CA0:  SUBWF  x76,W
0CA2:  BNZ   0CAA
....................     return 0; 
0CA4:  MOVLW  00
0CA6:  MOVWF  01
0CA8:  BRA    0CCC
....................   } 
....................   *dst = get_next_byte(); 
0CAA:  MOVFF  396,03
0CAE:  MOVFF  395,397
0CB2:  MOVFF  396,398
0CB6:  MOVLB  0
0CB8:  BRA    0C6E
0CBA:  MOVFF  398,FEA
0CBE:  MOVFF  397,FE9
0CC2:  MOVFF  01,FEF
....................   return 1; 
0CC6:  MOVLW  01
0CC8:  MOVWF  01
0CCA:  MOVLB  1
.................... } 
0CCC:  MOVLB  0
0CCE:  GOTO   0E5C (RETURN)
....................  
.................... void uart_send(void* buffer, uint8_t size) { 
....................   push_bytes(buffer, size); 
*
0F80:  MOVFF  3E4,3E7
0F84:  MOVFF  3E3,3E6
0F88:  MOVLB  3
0F8A:  CLRF   xE9
0F8C:  MOVFF  3E5,3E8
0F90:  MOVLB  0
0F92:  BRA    1206
....................   enable_interrupts(int_TBE); 
0F94:  BSF    F9D.4
....................  
....................   /* wait here until done */ 
....................   //while(wbuf_rd_idx != wbuf_wr_idx) {}; 
.................... } 
0F96:  GOTO   0FC8 (RETURN)
....................  
.................... /* UART IRQs */ 
....................  
.................... #int_RDA 
.................... void RDA_isr(void) 
.................... { 
....................   /* uart rx buffer can hold 2.x input bytes */ 
....................   do {  
....................     rbuf[rbuf_wr_idx++] = RCREG1; 
*
00C6:  MOVLB  1
00C8:  MOVF   x76,W
00CA:  INCF   x76,F
00CC:  CLRF   03
00CE:  ADDLW  C2
00D0:  MOVWF  FE9
00D2:  MOVLW  00
00D4:  ADDWFC 03,W
00D6:  MOVWF  FEA
00D8:  MOVFF  FAE,FEF
....................     if (rbuf_wr_idx == MAX_UART_SIZE) { 
00DC:  MOVF   x76,W
00DE:  SUBLW  B4
00E0:  BNZ   00E4
....................       rbuf_wr_idx = 0; 
00E2:  CLRF   x76
....................     } 
....................     uart_clear_errors(); 
00E4:  MOVLB  0
00E6:  BRA    00BA
....................   } while (kbhit()); 
00E8:  BTFSC  F9E.5
00EA:  BRA    00C6
....................   enable_interrupts(int_RDA); 
00EC:  BSF    F9D.5
.................... } 
....................  
00EE:  BCF    F9E.5
00F0:  GOTO   006C
.................... #int_TBE 
.................... void TBE_isr(void) 
.................... { 
....................   if (wbuf_rd_idx != wbuf_wr_idx){ 
*
0912:  MOVLB  2
0914:  MOVF   x2C,W
0916:  SUBWF  x2D,W
0918:  BZ    0938
....................     TXREG1 = wbuf[wbuf_rd_idx++]; 
091A:  MOVF   x2D,W
091C:  INCF   x2D,F
091E:  CLRF   03
0920:  ADDLW  78
0922:  MOVWF  FE9
0924:  MOVLW  01
0926:  ADDWFC 03,W
0928:  MOVWF  FEA
092A:  MOVFF  FEF,FAD
....................     if(wbuf_rd_idx == MAX_UART_SIZE) { 
092E:  MOVF   x2D,W
0930:  SUBLW  B4
0932:  BNZ   0936
....................       wbuf_rd_idx = 0; 
0934:  CLRF   x2D
....................     } 
....................   } else { 
0936:  BRA    093A
....................     disable_interrupts(int_TBE); 
0938:  BCF    F9D.4
....................   } 
.................... } 
....................  
093A:  BCF    F9E.4
093C:  MOVLB  0
093E:  GOTO   006C
.................... #bit CREN=getenv("BIT:CREN")  
.................... #BIT OERR = getenv("BIT:OERR") 
.................... void uart_clear_errors() 
.................... { 
....................   if (OERR) { 
*
00BA:  BTFSS  FAB.1
00BC:  BRA    00C2
....................     CREN = 0; 
00BE:  BCF    FAB.4
....................     CREN = 1; 
00C0:  BSF    FAB.4
....................   } 
.................... } 
00C2:  GOTO   00E8 (RETURN)
....................  
.................... #include "BA1474.h" 
.................... #include <18F45K22.h> 
.................... //////// Standard Header file for the PIC18F45K22 device //////////////// 
.................... #device PIC18F45K22 
.................... #list 
....................  
.................... #device adc=10 
.................... #device pass_strings=in_ram 
....................  
.................... #define LOADER_END 0x1FFF 
.................... #include <boot.h> 
.................... #undef LOADER_END 
.................... #define FLASH_SIZE getenv("FLASH_ERASE_SIZE") 
.................... #define LOADER_END   0x1FFF 
.................... #define LOADER_SIZE  0x3FF 
....................  
.................... #ifndef _bootloader 
.................... #build(reset=LOADER_END+1, interrupt=LOADER_END+9) 
....................  
.................... /* when in operational software, keep out of the bootloader sections */ 
.................... #org 0, 0xfff {} 
.................... #org 0x1000, 0x1ffe {} 
....................  
.................... #else 
....................  
.................... /* when in the bootloader, keep out of the operational sections */ 
.................... #org 0x2000, 0x7ffe {} 
*
06DC:  CLRF   x87
06DE:  BTFSC  F81.1
06E0:  INCF   x87,F
....................  
.................... #endif 
....................  
....................  
.................... #FUSES NOWDT                   //No Watch Dog Timer 
.................... #FUSES WDT128                  //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES INTRC_IO                //Internal RC Osc, no CLKOUT 
.................... #FUSES NOBROWNOUT              //No brownout reset 
.................... #FUSES WDT_SW                  //No Watch Dog Timer, enabled in Software 
.................... #FUSES NOLVP                   //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOPUT 
.................... #FUSES NOXINST                 //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(clock=64000000) 
.................... #use rs232(baud=921600,xmit=PIN_C6,rcv=PIN_C7,ERRORS) 
.................... #USE TIMER(TIMER=1,TICK=1us,BITS=32,NOISR) 
.................... #use spi(DO=PIN_A4, CLK=PIN_A3, ENABLE=PIN_A2, ENABLE_ACTIVE=0, DATA_HOLD=20, BITS=16) 
....................  
.................... #opt 9 
....................  
.................... #use fast_io(a) 
.................... #use fast_io(b) 
.................... #use fast_io(c) 
.................... #use fast_io(d) 
.................... #use fast_io(e) 
....................  
.................... #define safe_write_program_memory(address, pointer, size) \ 
....................   do { disable_interrupts(GLOBAL); write_program_memory(address, pointer, size); enable_interrupts(GLOBAL); delay_us(1000); } while (0) 
....................  
....................  
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
*
0A50:  MOVFF  3D8,3DE
0A54:  MOVFF  3D7,3DD
0A58:  MOVFF  3DA,3E0
0A5C:  MOVFF  3D9,3DF
0A60:  MOVLB  3
0A62:  MOVF   xDC,F
0A64:  BNZ   0A6C
0A66:  MOVF   xDB,W
0A68:  SUBLW  00
0A6A:  BC    0ACC
.................... { 
....................    if(*su1!=*su2) 
0A6C:  MOVFF  3DD,FE9
0A70:  MOVFF  3DE,FEA
0A74:  MOVFF  FEF,3E1
0A78:  MOVFF  3E0,03
0A7C:  MOVFF  3DF,FE9
0A80:  MOVFF  3E0,FEA
0A84:  MOVF   FEF,W
0A86:  SUBWF  xE1,W
0A88:  BZ    0AB6
....................       return ((*su1<*su2)?-1:+1); 
0A8A:  MOVFF  3DE,03
0A8E:  MOVFF  3DD,FE9
0A92:  MOVFF  3DE,FEA
0A96:  MOVFF  FEF,3E1
0A9A:  MOVFF  3E0,03
0A9E:  MOVFF  3DF,FE9
0AA2:  MOVFF  3E0,FEA
0AA6:  MOVF   FEF,W
0AA8:  SUBWF  xE1,W
0AAA:  BC    0AB0
0AAC:  MOVLW  FF
0AAE:  BRA    0AB2
0AB0:  MOVLW  01
0AB2:  MOVWF  01
0AB4:  BRA    0AD0
.................... } 
0AB6:  INCF   xDD,F
0AB8:  BTFSC  FD8.2
0ABA:  INCF   xDE,F
0ABC:  INCF   xDF,F
0ABE:  BTFSC  FD8.2
0AC0:  INCF   xE0,F
0AC2:  MOVF   xDB,W
0AC4:  BTFSC  FD8.2
0AC6:  DECF   xDC,F
0AC8:  DECF   xDB,F
0ACA:  BRA    0A62
.................... return 0; 
0ACC:  MOVLW  00
0ACE:  MOVWF  01
.................... } 
0AD0:  MOVLB  0
0AD2:  RETURN 0
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "comm.h" 
.................... /* 
....................  * comm.h 
....................  * 
....................  *  Created on: Mar 23, 2017 
....................  *      Author: asaf 
....................  */ 
....................  
.................... #ifndef COMM_H_ 
.................... #define COMM_H_ 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdbool.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                          stdbool.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard boolean definitions                                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __STDBOOL_H__ 
.................... #define __STDBOOL_H__ 
....................  
.................... //remove TRUE and FALSE added by CCS's device .h file 
.................... #if defined(TRUE) 
.................... #undef TRUE 
.................... #endif 
.................... #if defined(FALSE) 
.................... #undef FALSE 
.................... #endif 
....................  
.................... typedef int1   bool; 
.................... #define true   1 
.................... #define false  0 
.................... #define __bool_true_false_are_defined  1 
....................  
.................... #endif 
....................  
....................  
.................... #define MSG_MAX_MESSAGE_LEN 80 
....................  
.................... #ifndef MIN 
.................... #define MIN(x,y) ((x)<(y)?(x):(y)) 
.................... #endif 
.................... #ifndef MAX 
.................... #define	MAX(a,b) (((a)>(b))?(a):(b)) 
.................... #endif 
....................  
.................... #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0])) 
.................... #define MAX_INDEX_IN_ARRAY(x) (ARRAY_SIZE(x)-1) 
....................  
.................... void comm_init(); 
.................... bool comm_receive_message(void* buffer, uint16_t* size); 
.................... void comm_send_message(void* buffer, uint16_t size); 
....................  
....................  
....................  
.................... #endif /* COMM_H_ */ 
....................  
.................... #include "boot_version.h" 
.................... #ifndef BOOT_VERSION_H_ 
.................... #define BOOT_VERSION_H_ 
....................  
.................... #define VERSION_DAY 18 
.................... #define VERSION_MONTH 6 
.................... #define VERSION_YEAR 2018 
.................... #define VERSION_MAJOR 0xB 
.................... #define VERSION_MINOR 5 
....................  
.................... #endif /* BOOT_VERSION_H_ */ 
....................  
.................... #include "main.h" 
.................... #ifndef MAIN_H_ 
.................... #define MAIN_H_ 
....................  
.................... #define MAIN_ADDRESS 0x2700 
....................  
.................... #define ATOMIC_SET(var, val)    do { \ 
....................                                       disable_interrupts(GLOBAL); \ 
....................                                       var = val; \ 
....................                                       enable_interrupts(GLOBAL); \ 
....................                                 } while(0); 
....................  
.................... #endif /* MAIN_H_ */ 
....................  
.................... #include "timer.h" 
.................... #ifndef INCLUDE_TIMER_H_ 
.................... #define INCLUDE_TIMER_H_ 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdbool.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                          stdbool.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard boolean definitions                                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __STDBOOL_H__ 
.................... #define __STDBOOL_H__ 
....................  
.................... //remove TRUE and FALSE added by CCS's device .h file 
.................... #if defined(TRUE) 
.................... #undef TRUE 
.................... #endif 
.................... #if defined(FALSE) 
.................... #undef FALSE 
.................... #endif 
....................  
.................... typedef int1   bool; 
.................... #define true   1 
.................... #define false  0 
.................... #define __bool_true_false_are_defined  1 
....................  
.................... #endif 
....................  
....................  
.................... typedef void (*timer_func)(void* arg); 
....................  
.................... typedef struct { 
....................   //bool triggred; 
....................   uint32_t expTime; 
....................   void *arg; 
....................   timer_func func; 
.................... } timer_task_t; 
....................  
.................... #INLINE 
.................... uint32_t timer_get_us_count(); 
.................... bool timer_registerTask(uint32_t expTime, timer_func func, void *arg); 
.................... void timer_yield(); 
....................  
.................... #endif /* INCLUDE_TIMER_H_ */ 
....................  
.................... #include "uart.h" 
.................... /* 
....................  * uart.h 
....................  * 
....................  *  Created on: Mar 23, 2017 
....................  *      Author: asaf 
....................  */ 
....................  
.................... #ifndef UART_H_ 
.................... #define UART_H_ 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... void uart_init(); 
.................... void uart_disable(); 
.................... uint8_t uart_get_byte_blocking(); 
.................... uint8_t uart_get_byte_nonblocking(uint8_t *dst); 
.................... void uart_send(void* buffer, uint8_t size); 
.................... void uart_clear_errors(); 
....................  
.................... #endif /* UART_H_ */ 
....................  
.................... #include "message.h" 
.................... /* 
....................  * message.h 
....................  * 
....................  *  Created on: Mar 23, 2017 
....................  *      Author: asaf 
....................  */ 
....................  
.................... #ifndef MESSAGE_H_ 
.................... #define MESSAGE_H_ 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include "calibration.h" 
.................... #ifndef CALIBRATION_H_ 
.................... #define CALIBRATION_H_ 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdbool.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                          stdbool.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard boolean definitions                                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __STDBOOL_H__ 
.................... #define __STDBOOL_H__ 
....................  
.................... //remove TRUE and FALSE added by CCS's device .h file 
.................... #if defined(TRUE) 
.................... #undef TRUE 
.................... #endif 
.................... #if defined(FALSE) 
.................... #undef FALSE 
.................... #endif 
....................  
.................... typedef int1   bool; 
.................... #define true   1 
.................... #define false  0 
.................... #define __bool_true_false_are_defined  1 
....................  
.................... #endif 
....................  
....................  
.................... #define CALIBRATION_AREA_START 0x4000 
.................... #define CALIBRATION_AREA_END 0x4FFF 
....................  
.................... typedef enum { 
....................   CALIBRATION_TABLE_PARAMS = 0, 
....................   CALIBRATION_TABLE_PA_GAINS_1 = 1, 
....................   CALIBRATION_TABLE_PA_GAINS_2 = 2, 
....................   CALIBRATION_TABLE_MAX = 3 
.................... } calibration_table_id_t; 
....................  
.................... typedef enum { 
....................   PARAM_CAL_TBL_VERSION = 0, 
....................   PARAM_SERIAL_NUM = 1, 
....................   PARAM_TEMP_MULT = 2, 
....................   PARAM_FWD_MULT = 3, 
....................   PARAM_REV_MULT = 4, 
....................   PARAM_INP_PWR_MULT = 5, 
....................   PARAM_PWR_CURRENT_MULT = 6, 
....................   PARAM_PRE_AMP_MULT = 7, 
....................   PARAM_ISENSE_PA1_MULT = 8, 
....................   PARAM_ISENSE_PA2_MULT = 9, 
....................   PARAM_BOOT_WAIT_TIME_USEC = 10, 
....................   PARAM_TX_ON_TIMING_USEC = 11, 
....................   PARAM_TX_OFF_TIMING_USEC = 12, 
....................   PARAM_PA_ON_TIMING_USEC = 13, 
....................   PARAM_PA_OFF_TIMING_USEC = 14, 
....................   PARAM_ANT_SEL_TIMING_USEC = 15, 
....................   PARAM_FWD_SAMP_TIMING_USEC = 16, 
....................   PARAM_REV_SAMP_TIMING_USEC = 17, 
....................   PARAM_INP_PWR_SAMP_TIMING_USEC = 18, 
.................... } calibration_param_t; 
....................  
.................... #define CALIBRATION_TABLE_INDEX_MAX 32 
....................  
.................... void get_calibration_table_data(calibration_table_id_t table_id, void* table_data); 
.................... void set_calibration_table_data(calibration_table_id_t table_id, void* table_data); 
.................... #INLINE 
.................... uint16_t get_calibration_param(calibration_table_id_t table, uint8_t index); 
.................... void set_calibration_param(calibration_table_id_t table, uint8_t index, uint16_t value); 
....................  
.................... #endif /* CALIBRATION_H_ */ 
....................  
....................  
.................... enum { 
....................   NUM_ADC_SAMPLES = 4, 
.................... }; 
....................  
.................... enum { 
....................   OP_CONTROL_MESSAGE = 0x00, 
....................   OP_VERSION_REQUEST_MESSAGE = 0x02, 
....................   OP_CHANGE_MODE_MESSAGE = 0x03, 
....................   OP_SET_CALIBRATION_TABLE_MESSAGE = 0x04, 
....................   OP_GET_CALIBRATION_TABLE_MESSAGE = 0x05, 
....................   OP_SET_DATA_LINE_MESSAGE = 0x06, 
....................   OP_GET_DATA_LINE_MESSAGE = 0x07, 
....................   OP_FINISH_UPDATE_PROCESS_MESSAGE = 0x08, 
....................   OP_BIT_STATUS_REQUEST_MESSAGE = 0x09, 
.................... }; 
....................  
.................... enum { 
....................   OP_ACK_RESPONSE = 0x80, 
....................   OP_SF_STATUS_RESPONSE = 0x81, 
....................   OP_VERSION_RESPONSE = 0x82, 
....................   OP_GET_CALIBRATION_TABLE_RESPONSE = 0x85, 
....................   OP_SET_DATA_LINE_RESPONSE = 0x86, 
....................   OP_GET_DATA_LINE_RESPONSE = 0x87, 
....................   OP_BIT_STATUS_RESPONSE = 0x89, 
.................... }; 
....................  
.................... typedef enum { 
....................   MODE_OPERATIONAL = 0, 
....................   MODE_TECHNICIAN = 1, 
....................   MODE_MAINTENANCE = 2, 
.................... } software_mode_t; 
....................  
.................... enum { 
....................   CALIBRATION_TABLE_TEMP = 0, 
....................   CALIBRATION_TABLE_FWD = 1, 
....................   CALIBRATION_TABLE_REV = 2, 
....................   CALIBRATION_TABLE_INP = 3, 
....................   CALIBRATION_TABLE_CURRENT = 4, 
....................   CALIBRATION_TABLE_PA_BIAS = 5, 
....................   CALIBRATION_TABLE_TIMING = 6, 
....................   CALIBRATION_TABLE_GENERAL = 7, 
.................... }; 
....................  
.................... enum { 
....................   PROGRAMMING_STATUS_OK = 0, 
....................   PROGRAMMING_STATUS_ERROR = 1, 
.................... }; 
....................  
.................... typedef struct message_t { 
....................   uint8_t opcode; 
....................   uint8_t payload[]; /* this will include the payload and the crc */ 
.................... } message_t; 
....................  
.................... typedef struct generic_response_t { 
....................   uint8_t opcode; 
.................... } generic_response_t; 
....................  
.................... /* message payloads*/ 
....................  
.................... typedef struct control_bits_t { 
....................   uint8_t tx_on : 1; 
....................   uint8_t pa_gain : 3; 
....................   uint8_t tx_ant : 1; 
....................   uint8_t amplifier_operation_frequency : 1; 
....................   uint8_t reset : 1; 
....................   uint8_t dont_change : 1; 
.................... } control_bits_t; 
....................  
.................... typedef struct control_message_payload_t { 
....................   control_bits_t bits; 
....................   uint16_t control_identifier; 
.................... } control_message_payload_t; 
....................  
.................... typedef struct change_mode_message_payload_t { 
....................   uint8_t mode; 
.................... } change_mode_message_payload_t; 
....................  
....................  
.................... typedef struct set_calibration_table_message_payload_t { 
....................   uint8_t table_id; 
....................   uint16_t params[CALIBRATION_TABLE_INDEX_MAX]; 
.................... } set_calibration_table_message_payload_t; 
....................  
.................... typedef struct get_calibration_table_message_payload_t { 
....................   uint8_t table_id; 
.................... } get_calibration_table_message_payload_t; 
....................  
.................... typedef struct set_data_line_payload_t { 
....................   uint32_t address; 
....................   uint8_t data[64]; 
.................... } set_data_line_payload_t; 
....................  
.................... typedef struct get_data_line_payload_t { 
....................   uint32_t address; 
.................... } get_data_line_payload_t; 
....................  
.................... /* responses */ 
....................  
.................... typedef struct ack_response_t { 
....................   generic_response_t generic; 
.................... } ack_response_t; 
....................  
.................... typedef struct sf_status_response_t { 
....................   generic_response_t generic; 
....................   control_bits_t last_control_bits; 
....................   uint16_t tti_counter; 
....................   uint16_t control_identifier; 
....................   uint16_t fwd_power_values[NUM_ADC_SAMPLES]; 
....................   uint16_t reverse_power_values[NUM_ADC_SAMPLES]; 
....................   uint16_t input_power_values[NUM_ADC_SAMPLES]; 
....................   uint16_t pre_amp_power_values[NUM_ADC_SAMPLES]; 
....................   uint16_t temperature; 
....................   uint16_t power_amplifier_current; 
.................... } sf_status_response_t; 
....................  
.................... typedef struct bit_status_response_t { 
....................   generic_response_t generic; 
....................   control_bits_t last_control_bits; 
....................   uint16_t tti_counter; 
....................   uint8_t mode; 
.................... } bit_status_response_t; 
....................  
.................... typedef struct version_response_t { 
....................   generic_response_t generic; 
....................   uint8_t day; 
....................   uint8_t month; 
....................   uint16_t year; 
....................   uint8_t major; 
....................   uint8_t minor; 
....................   uint16_t serial_number; 
.................... } version_response_t; 
....................  
.................... typedef struct calibration_table_response_t { 
....................   generic_response_t generic; 
....................   uint8_t table_id; 
....................   uint16_t params[CALIBRATION_TABLE_INDEX_MAX]; 
.................... } calibration_table_response_t; 
....................  
.................... typedef struct set_data_line_response_t { 
....................   generic_response_t generic; 
....................   uint32_t address; 
....................   uint8_t status; 
.................... } set_data_line_response_t; 
....................  
.................... typedef struct get_data_line_response_t { 
....................   generic_response_t generic; 
....................   uint32_t address; 
....................   uint8_t data[64]; 
.................... } get_data_line_response_t; 
....................  
.................... #endif /* MESSAGE_H_ */ 
....................  
.................... #include "calibration.h" 
.................... #ifndef CALIBRATION_H_ 
.................... #define CALIBRATION_H_ 
....................  
.................... #include <stdint.h> 
.................... #include <stdbool.h> 
....................  
.................... #define CALIBRATION_AREA_START 0x4000 
.................... #define CALIBRATION_AREA_END 0x4FFF 
....................  
.................... typedef enum { 
....................   CALIBRATION_TABLE_PARAMS = 0, 
....................   CALIBRATION_TABLE_PA_GAINS_1 = 1, 
....................   CALIBRATION_TABLE_PA_GAINS_2 = 2, 
....................   CALIBRATION_TABLE_MAX = 3 
.................... } calibration_table_id_t; 
....................  
.................... typedef enum { 
....................   PARAM_CAL_TBL_VERSION = 0, 
....................   PARAM_SERIAL_NUM = 1, 
....................   PARAM_TEMP_MULT = 2, 
....................   PARAM_FWD_MULT = 3, 
....................   PARAM_REV_MULT = 4, 
....................   PARAM_INP_PWR_MULT = 5, 
....................   PARAM_PWR_CURRENT_MULT = 6, 
....................   PARAM_PRE_AMP_MULT = 7, 
....................   PARAM_ISENSE_PA1_MULT = 8, 
....................   PARAM_ISENSE_PA2_MULT = 9, 
....................   PARAM_BOOT_WAIT_TIME_USEC = 10, 
....................   PARAM_TX_ON_TIMING_USEC = 11, 
....................   PARAM_TX_OFF_TIMING_USEC = 12, 
....................   PARAM_PA_ON_TIMING_USEC = 13, 
....................   PARAM_PA_OFF_TIMING_USEC = 14, 
....................   PARAM_ANT_SEL_TIMING_USEC = 15, 
....................   PARAM_FWD_SAMP_TIMING_USEC = 16, 
....................   PARAM_REV_SAMP_TIMING_USEC = 17, 
....................   PARAM_INP_PWR_SAMP_TIMING_USEC = 18, 
.................... } calibration_param_t; 
....................  
.................... #define CALIBRATION_TABLE_INDEX_MAX 32 
....................  
.................... void get_calibration_table_data(calibration_table_id_t table_id, void* table_data); 
.................... void set_calibration_table_data(calibration_table_id_t table_id, void* table_data); 
.................... #INLINE 
.................... uint16_t get_calibration_param(calibration_table_id_t table, uint8_t index); 
.................... void set_calibration_param(calibration_table_id_t table, uint8_t index, uint16_t value); 
....................  
.................... #endif /* CALIBRATION_H_ */ 
....................  
....................  
.................... #define BOOT_WAIT_TIME_US 500000 
....................  
.................... typedef struct { 
....................   bool run_loader; 
....................   bool is_first_page_dirty; 
.................... } bootloader_metadata_t; 
....................  
.................... #define ROM_METADATA_ADDRESS 0x1000 
.................... #ORG ROM_METADATA_ADDRESS,ROM_METADATA_ADDRESS + getenv("FLASH_ERASE_SIZE") {} 
....................  
.................... static void set_metadata(bootloader_metadata_t* value) { 
....................   union { 
....................     bootloader_metadata_t value; 
....................     uint8_t padding[getenv("FLASH_ERASE_SIZE")]; 
....................   } data; 
....................  
....................   memcpy(&data.value, value, sizeof(data.value)); 
*
0EF4:  MOVLW  03
0EF6:  MOVWF  FEA
0EF8:  MOVLW  A3
0EFA:  MOVWF  FE9
0EFC:  MOVFF  3A2,FE2
0F00:  MOVFF  3A1,FE1
0F04:  MOVFF  FE6,FEE
....................   safe_write_program_memory(ROM_METADATA_ADDRESS, &data, sizeof(data)); 
0F08:  BCF    FF2.6
0F0A:  BCF    FF2.7
0F0C:  BTFSC  FF2.7
0F0E:  BRA    0F0A
0F10:  CLRF   FF8
0F12:  MOVLW  10
0F14:  MOVWF  FF7
0F16:  CLRF   FF6
0F18:  MOVLW  03
0F1A:  MOVWF  FEA
0F1C:  MOVLW  A3
0F1E:  MOVWF  FE9
0F20:  MOVLW  40
0F22:  MOVLB  3
0F24:  MOVWF  xE3
0F26:  MOVLB  0
0F28:  RCALL  0AF4
0F2A:  MOVLW  C0
0F2C:  IORWF  FF2,F
0F2E:  MOVLW  01
0F30:  MOVLB  3
0F32:  MOVWF  xE3
0F34:  MOVLB  0
0F36:  RCALL  0B36
.................... } 
0F38:  RETURN 0
....................  
.................... bootloader_metadata_t *get_metadata() { 
....................   static bootloader_metadata_t meta; 
....................   read_program_memory(ROM_METADATA_ADDRESS, &meta, sizeof(bootloader_metadata_t)); 
*
0A04:  CLRF   FF8
0A06:  MOVLW  10
0A08:  MOVWF  FF7
0A0A:  CLRF   FF6
0A0C:  MOVLW  02
0A0E:  MOVWF  FEA
0A10:  MOVLW  30
0A12:  MOVWF  FE9
0A14:  MOVLB  3
0A16:  CLRF   xDE
0A18:  MOVLW  01
0A1A:  MOVWF  xDD
0A1C:  MOVLB  0
0A1E:  RCALL  09E6
....................   return &meta; 
0A20:  MOVLW  30
0A22:  MOVWF  01
0A24:  MOVLW  02
0A26:  MOVWF  02
.................... } 
0A28:  RETURN 0
....................  
.................... static void set_software_ready(bool value) { 
*
0F3A:  RCALL  0A04
0F3C:  MOVFF  02,3A0
0F40:  MOVFF  01,39F
....................   bootloader_metadata_t *temp_metadata = get_metadata(); 
....................   temp_metadata->run_loader = ~value; 
0F44:  MOVLB  3
0F46:  MOVFF  3A0,03
0F4A:  MOVFF  39F,3A1
0F4E:  MOVFF  3A0,3A2
0F52:  MOVF   x9E,W
0F54:  XORLW  FF
0F56:  MOVWF  01
0F58:  BTFSC  FE8.0
0F5A:  BRA    0F68
0F5C:  MOVFF  3A2,FEA
0F60:  MOVFF  3A1,FE9
0F64:  BCF    FEF.0
0F66:  BRA    0F72
0F68:  MOVFF  3A2,FEA
0F6C:  MOVFF  3A1,FE9
0F70:  BSF    FEF.0
....................   set_metadata(temp_metadata); 
0F72:  MOVFF  3A0,3A2
0F76:  MOVFF  39F,3A1
0F7A:  MOVLB  0
0F7C:  RCALL  0EF4
.................... } 
0F7E:  RETURN 0
....................  
.................... static void set_first_page_clean() { 
....................   bootloader_metadata_t *temp_metadata = get_metadata(); 
....................   temp_metadata->is_first_page_dirty = false; 
....................   set_metadata(temp_metadata); 
.................... } 
....................  
.................... static void set_first_page_dirty() { 
*
0FCA:  RCALL  0A04
0FCC:  MOVFF  02,398
0FD0:  MOVFF  01,397
....................   bootloader_metadata_t *temp_metadata = get_metadata(); 
....................   temp_metadata->is_first_page_dirty = true; 
0FD4:  MOVLB  3
0FD6:  MOVFF  397,FE9
0FDA:  MOVFF  398,FEA
0FDE:  BSF    FEF.1
....................   set_metadata(temp_metadata); 
0FE0:  MOVFF  398,3A2
0FE4:  MOVFF  397,3A1
0FE8:  MOVLB  0
0FEA:  RCALL  0EF4
.................... } 
0FEC:  GOTO   15C8 (RETURN)
....................  
.................... #define BOOTLOADER_FIRST_PAGE_ADDRESS 0x1100 
.................... #org BOOTLOADER_FIRST_PAGE_ADDRESS, BOOTLOADER_FIRST_PAGE_ADDRESS + getenv("FLASH_ERASE_SIZE") {} 
....................  
....................  
.................... //the main program overwrites the interrupt handler in the first page, so we need to save/restore it. 
.................... static void fix_first_page() { 
*
0B80:  BCF    xD2.0
....................   uint8_t reset_vector[] = { 0x80, 0xEF, 0x00, 0xF0 }; 
*
0B60:  MOVLW  80
0B62:  MOVLB  3
0B64:  MOVWF  x8A
0B66:  MOVLW  EF
0B68:  MOVWF  x8B
0B6A:  CLRF   x8C
0B6C:  MOVLW  F0
0B6E:  MOVWF  x8D
....................   uint8_t interrupt_vector[] = { 0x04, 0x6E, 0xD8, 0xCf }; 
0B70:  MOVLW  04
0B72:  MOVWF  x8E
0B74:  MOVLW  6E
0B76:  MOVWF  x8F
0B78:  MOVLW  D8
0B7A:  MOVWF  x90
0B7C:  MOVLW  CF
0B7E:  MOVWF  x91
....................   uint8_t start_bytes[getenv("FLASH_ERASE_SIZE")]; 
....................   bool should_write = false; 
....................  
....................   read_program_memory(0, start_bytes, sizeof(start_bytes)); 
*
0B82:  CLRF   FF8
0B84:  CLRF   FF7
0B86:  CLRF   FF6
0B88:  MOVLW  03
0B8A:  MOVWF  FEA
0B8C:  MOVLW  92
0B8E:  MOVWF  FE9
0B90:  CLRF   xDE
0B92:  MOVLW  40
0B94:  MOVWF  xDD
0B96:  MOVLB  0
0B98:  RCALL  09E6
....................   //check if the reset vector contains the correct jump, if not, overwrite it 
....................   if (memcmp(start_bytes, reset_vector, sizeof(reset_vector)) != 0) { 
0B9A:  MOVLW  03
0B9C:  MOVLB  3
0B9E:  MOVWF  xD8
0BA0:  MOVLW  92
0BA2:  MOVWF  xD7
0BA4:  MOVLW  03
0BA6:  MOVWF  xDA
0BA8:  MOVLW  8A
0BAA:  MOVWF  xD9
0BAC:  CLRF   xDC
0BAE:  MOVLW  04
0BB0:  MOVWF  xDB
0BB2:  MOVLB  0
0BB4:  RCALL  0A50
0BB6:  MOVF   01,F
0BB8:  BZ    0BDA
....................     should_write = true; 
0BBA:  MOVLB  3
0BBC:  BSF    xD2.0
....................     memcpy(start_bytes, reset_vector, sizeof(reset_vector)); 
0BBE:  MOVLW  03
0BC0:  MOVWF  FEA
0BC2:  MOVLW  92
0BC4:  MOVWF  FE9
0BC6:  MOVLW  03
0BC8:  MOVWF  FE2
0BCA:  MOVLW  8A
0BCC:  MOVWF  FE1
0BCE:  MOVLW  04
0BD0:  MOVWF  01
0BD2:  MOVFF  FE6,FEE
0BD6:  DECFSZ 01,F
0BD8:  BRA    0BD2
....................   } 
....................  
....................   //check if the interrupt handler contains the correct jump, if not, overwrite it 
....................  if (memcmp(start_bytes+8, interrupt_vector, sizeof(interrupt_vector)) != 0) { 
0BDA:  MOVLW  03
0BDC:  MOVLB  3
0BDE:  MOVWF  xD8
0BE0:  MOVLW  9A
0BE2:  MOVWF  xD7
0BE4:  MOVLW  03
0BE6:  MOVWF  xDA
0BE8:  MOVLW  8E
0BEA:  MOVWF  xD9
0BEC:  CLRF   xDC
0BEE:  MOVLW  04
0BF0:  MOVWF  xDB
0BF2:  MOVLB  0
0BF4:  RCALL  0A50
0BF6:  MOVF   01,F
0BF8:  BZ    0C1A
....................     should_write = true; 
0BFA:  MOVLB  3
0BFC:  BSF    xD2.0
....................     memcpy(start_bytes+8, interrupt_vector, sizeof(interrupt_vector)); 
0BFE:  MOVLW  03
0C00:  MOVWF  FEA
0C02:  MOVLW  9A
0C04:  MOVWF  FE9
0C06:  MOVLW  03
0C08:  MOVWF  FE2
0C0A:  MOVLW  8E
0C0C:  MOVWF  FE1
0C0E:  MOVLW  04
0C10:  MOVWF  01
0C12:  MOVFF  FE6,FEE
0C16:  DECFSZ 01,F
0C18:  BRA    0C12
....................   } 
....................  
....................   if(should_write) { 
0C1A:  MOVLB  3
0C1C:  BTFSS  xD2.0
0C1E:  BRA    0C4E
....................     safe_write_program_memory(0x0000, start_bytes, sizeof(start_bytes)); 
0C20:  BCF    FF2.6
0C22:  BCF    FF2.7
0C24:  BTFSC  FF2.7
0C26:  BRA    0C22
0C28:  CLRF   FF8
0C2A:  CLRF   FF7
0C2C:  CLRF   FF6
0C2E:  MOVLW  03
0C30:  MOVWF  FEA
0C32:  MOVLW  92
0C34:  MOVWF  FE9
0C36:  MOVLW  40
0C38:  MOVWF  xE3
0C3A:  MOVLB  0
0C3C:  RCALL  0AF4
0C3E:  MOVLW  C0
0C40:  IORWF  FF2,F
0C42:  MOVLW  01
0C44:  MOVLB  3
0C46:  MOVWF  xE3
0C48:  MOVLB  0
0C4A:  RCALL  0B36
0C4C:  MOVLB  3
....................   } 
.................... } 
0C4E:  MOVLB  0
0C50:  GOTO   0700 (RETURN)
....................  
.................... static void handle_set_data_line_message(void* payload_buffer) { 
*
12EE:  MOVFF  395,397
12F2:  MOVFF  394,396
....................   set_data_line_payload_t* payload = (set_data_line_payload_t*)payload_buffer; 
....................  
....................   set_data_line_response_t response = {}; 
12F6:  MOVLB  3
12F8:  CLRF   x98
12FA:  CLRF   x99
12FC:  CLRF   x9A
12FE:  CLRF   x9B
1300:  CLRF   x9C
1302:  CLRF   x9D
....................   response.generic.opcode = OP_SET_DATA_LINE_RESPONSE; 
1304:  MOVLW  86
1306:  MOVWF  x98
....................   response.address = payload->address; 
1308:  MOVFF  396,FE9
130C:  MOVFF  397,FEA
1310:  MOVFF  FEF,00
1314:  MOVFF  FEC,01
1318:  MOVFF  FEC,02
131C:  MOVFF  FEC,03
1320:  MOVFF  03,39C
1324:  MOVFF  02,39B
1328:  MOVFF  01,39A
132C:  MOVFF  00,399
....................   response.status = PROGRAMMING_STATUS_OK; 
1330:  CLRF   x9D
....................  
....................   if ((payload->address < CALIBRATION_AREA_START || payload->address > CALIBRATION_AREA_END) 
....................       && payload->address > LOADER_END && payload->address < 65535) { 
1332:  MOVFF  396,FE9
1336:  MOVFF  397,FEA
133A:  MOVFF  FEF,39E
133E:  MOVFF  FEC,39F
1342:  MOVFF  FEC,3A0
1346:  MOVFF  FEC,3A1
134A:  MOVF   xA1,F
134C:  BNZ   1358
134E:  MOVF   xA0,F
1350:  BNZ   1358
1352:  MOVF   x9F,W
1354:  SUBLW  3F
1356:  BC    1380
1358:  MOVFF  396,FE9
135C:  MOVFF  397,FEA
1360:  MOVFF  FEF,39E
1364:  MOVFF  FEC,39F
1368:  MOVFF  FEC,3A0
136C:  MOVFF  FEC,3A1
1370:  MOVF   xA1,F
1372:  BNZ   1380
1374:  MOVF   xA0,F
1376:  BNZ   1380
1378:  MOVF   x9F,W
137A:  SUBLW  4F
137C:  BTFSC  FD8.0
137E:  BRA    145C
1380:  MOVFF  396,FE9
1384:  MOVFF  397,FEA
1388:  MOVFF  FEF,39E
138C:  MOVFF  FEC,39F
1390:  MOVFF  FEC,3A0
1394:  MOVFF  FEC,3A1
1398:  MOVF   xA1,F
139A:  BNZ   13A6
139C:  MOVF   xA0,F
139E:  BNZ   13A6
13A0:  MOVF   x9F,W
13A2:  SUBLW  1F
13A4:  BC    145C
13A6:  MOVFF  396,FE9
13AA:  MOVFF  397,FEA
13AE:  MOVFF  FEF,39E
13B2:  MOVFF  FEC,39F
13B6:  MOVFF  FEC,3A0
13BA:  MOVFF  FEC,3A1
13BE:  MOVF   xA1,F
13C0:  BNZ   145C
13C2:  MOVF   xA0,F
13C4:  BNZ   145C
13C6:  MOVF   x9F,W
13C8:  SUBLW  FF
13CA:  BNC   145C
13CC:  BNZ   13D4
13CE:  MOVF   x9E,W
13D0:  SUBLW  FE
13D2:  BNC   145C
....................     if (!get_metadata()->run_loader) { 
13D4:  MOVLB  0
13D6:  CALL   0A04
13DA:  MOVFF  02,39F
13DE:  MOVFF  01,39E
13E2:  MOVLB  3
13E4:  MOVFF  39E,FE9
13E8:  MOVFF  39F,FEA
13EC:  BTFSC  FEF.0
13EE:  BRA    13F8
....................       set_software_ready(false); 
13F0:  CLRF   x9E
13F2:  MOVLB  0
13F4:  RCALL  0F3A
13F6:  MOVLB  3
....................     } 
....................  
....................     safe_write_program_memory(payload->address, payload->data, sizeof(payload->data)); 
13F8:  BCF    FF2.6
13FA:  BCF    FF2.7
13FC:  BTFSC  FF2.7
13FE:  BRA    13FA
1400:  MOVF   x96,W
1402:  MOVWF  FE9
1404:  MOVF   x97,W
1406:  MOVWF  FEA
1408:  MOVFF  FEF,39E
140C:  MOVFF  FEC,39F
1410:  MOVFF  FEC,3A0
1414:  MOVFF  FEC,3A1
1418:  MOVF   FED,F
141A:  MOVF   FED,F
141C:  MOVF   FED,F
141E:  MOVLW  04
1420:  ADDWF  x96,W
1422:  MOVWF  xA2
1424:  MOVLW  00
1426:  ADDWFC x97,W
1428:  MOVWF  xA3
142A:  MOVFF  3A0,FF8
142E:  MOVFF  39F,FF7
1432:  MOVFF  39E,FF6
1436:  MOVFF  3A3,FEA
143A:  MOVFF  3A2,FE9
143E:  MOVLW  40
1440:  MOVWF  xE3
1442:  MOVLB  0
1444:  CALL   0AF4
1448:  MOVLW  C0
144A:  IORWF  FF2,F
144C:  MOVLW  01
144E:  MOVLB  3
1450:  MOVWF  xE3
1452:  MOVLB  0
1454:  CALL   0B36
....................   } 
....................   else { 
1458:  BRA    1468
145A:  MOVLB  3
....................     delay_us(1); 
145C:  MOVLW  04
145E:  MOVWF  00
1460:  DECFSZ 00,F
1462:  BRA    1460
1464:  BRA    1466
1466:  NOP   
....................   } 
....................  
....................   comm_send_message(&response, sizeof(response)); 
1468:  MOVLW  03
146A:  MOVLB  3
146C:  MOVWF  xDE
146E:  MOVLW  98
1470:  MOVWF  xDD
1472:  CLRF   xE0
1474:  MOVLW  06
1476:  MOVWF  xDF
1478:  MOVLB  0
147A:  RCALL  0F9A
.................... } 
147C:  RETURN 0
....................  
.................... static void handle_get_data_line_message(void* payload_buffer) { 
147E:  MOVFF  395,397
1482:  MOVFF  394,396
....................   get_data_line_payload_t* payload = (get_data_line_payload_t*)payload_buffer; 
....................   get_data_line_response_t response = {}; 
1486:  MOVLB  3
1488:  CLRF   x98
148A:  CLRF   x99
148C:  CLRF   x9A
148E:  CLRF   x9B
1490:  CLRF   x9C
1492:  CLRF   x9D
1494:  CLRF   x9E
1496:  CLRF   x9F
1498:  CLRF   xA0
149A:  CLRF   xA1
149C:  CLRF   xA2
149E:  CLRF   xA3
14A0:  CLRF   xA4
14A2:  CLRF   xA5
14A4:  CLRF   xA6
14A6:  CLRF   xA7
14A8:  CLRF   xA8
14AA:  CLRF   xA9
14AC:  CLRF   xAA
14AE:  CLRF   xAB
14B0:  CLRF   xAC
14B2:  CLRF   xAD
14B4:  CLRF   xAE
14B6:  CLRF   xAF
14B8:  CLRF   xB0
14BA:  CLRF   xB1
14BC:  CLRF   xB2
14BE:  CLRF   xB3
14C0:  CLRF   xB4
14C2:  CLRF   xB5
14C4:  CLRF   xB6
14C6:  CLRF   xB7
14C8:  CLRF   xB8
14CA:  CLRF   xB9
14CC:  CLRF   xBA
14CE:  CLRF   xBB
14D0:  CLRF   xBC
14D2:  CLRF   xBD
14D4:  CLRF   xBE
14D6:  CLRF   xBF
14D8:  CLRF   xC0
14DA:  CLRF   xC1
14DC:  CLRF   xC2
14DE:  CLRF   xC3
14E0:  CLRF   xC4
14E2:  CLRF   xC5
14E4:  CLRF   xC6
14E6:  CLRF   xC7
14E8:  CLRF   xC8
14EA:  CLRF   xC9
14EC:  CLRF   xCA
14EE:  CLRF   xCB
14F0:  CLRF   xCC
14F2:  CLRF   xCD
14F4:  CLRF   xCE
14F6:  CLRF   xCF
14F8:  CLRF   xD0
14FA:  CLRF   xD1
14FC:  CLRF   xD2
14FE:  CLRF   xD3
1500:  CLRF   xD4
1502:  CLRF   xD5
1504:  CLRF   xD6
1506:  CLRF   xD7
1508:  CLRF   xD8
150A:  CLRF   xD9
150C:  CLRF   xDA
150E:  CLRF   xDB
1510:  CLRF   xDC
....................  
....................   response.generic.opcode = OP_GET_DATA_LINE_RESPONSE; 
1512:  MOVLW  87
1514:  MOVWF  x98
....................   response.address = payload->address; 
1516:  MOVFF  396,FE9
151A:  MOVFF  397,FEA
151E:  MOVFF  FEF,00
1522:  MOVFF  FEC,01
1526:  MOVFF  FEC,02
152A:  MOVFF  FEC,03
152E:  MOVFF  03,39C
1532:  MOVFF  02,39B
1536:  MOVFF  01,39A
153A:  MOVFF  00,399
....................   read_program_memory(response.address, response.data, sizeof(response.data)); 
153E:  CLRF   FF8
1540:  MOVFF  39A,FF7
1544:  MOVFF  399,FF6
1548:  MOVLW  03
154A:  MOVWF  FEA
154C:  MOVLW  9D
154E:  MOVWF  FE9
1550:  CLRF   xDE
1552:  MOVLW  40
1554:  MOVWF  xDD
1556:  MOVLB  0
1558:  CALL   09E6
....................  
....................   comm_send_message(&response, sizeof(response)); 
155C:  MOVLW  03
155E:  MOVLB  3
1560:  MOVWF  xDE
1562:  MOVLW  98
1564:  MOVWF  xDD
1566:  CLRF   xE0
1568:  MOVLW  45
156A:  MOVWF  xDF
156C:  MOVLB  0
156E:  RCALL  0F9A
.................... } 
1570:  RETURN 0
....................  
.................... static void handle_version_request_message(void* payload_buffer) { 
....................   version_response_t response = {}; 
1572:  MOVLB  3
1574:  CLRF   x96
1576:  CLRF   x97
1578:  CLRF   x98
157A:  CLRF   x99
157C:  CLRF   x9A
157E:  CLRF   x9B
1580:  CLRF   x9C
1582:  CLRF   x9D
1584:  CLRF   x9E
....................   response.generic.opcode = OP_VERSION_RESPONSE; 
1586:  MOVLW  82
1588:  MOVWF  x96
....................   response.day = VERSION_DAY; 
158A:  MOVLW  12
158C:  MOVWF  x97
....................   response.month = VERSION_MONTH; 
158E:  MOVLW  06
1590:  MOVWF  x98
....................   response.year = VERSION_YEAR; 
1592:  MOVLW  07
1594:  MOVWF  x9A
1596:  MOVLW  E2
1598:  MOVWF  x99
....................   response.major = VERSION_MAJOR; 
159A:  MOVLW  0B
159C:  MOVWF  x9B
....................   response.minor = VERSION_MINOR; 
159E:  MOVLW  05
15A0:  MOVWF  x9C
....................   response.serial_number = 0; 
15A2:  CLRF   x9E
15A4:  CLRF   x9D
....................   comm_send_message(&response, sizeof(response)); 
15A6:  MOVLW  03
15A8:  MOVWF  xDE
15AA:  MOVLW  96
15AC:  MOVWF  xDD
15AE:  CLRF   xE0
15B0:  MOVLW  09
15B2:  MOVWF  xDF
15B4:  MOVLB  0
15B6:  RCALL  0F9A
.................... } 
15B8:  RETURN 0
....................  
.................... static void handle_finish_update_process_message(void* payload_buffer) { 
....................   ack_response_t response = {}; 
15BA:  MOVLB  3
15BC:  CLRF   x96
....................  
....................   set_software_ready(true); 
15BE:  MOVLW  01
15C0:  MOVWF  x9E
15C2:  MOVLB  0
15C4:  RCALL  0F3A
....................   set_first_page_dirty(); 
15C6:  BRA    0FCA
....................   response.generic.opcode = OP_ACK_RESPONSE; 
15C8:  MOVLW  80
15CA:  MOVLB  3
15CC:  MOVWF  x96
....................   comm_send_message(&response, sizeof(response)); 
15CE:  MOVLW  03
15D0:  MOVWF  xDE
15D2:  MOVLW  96
15D4:  MOVWF  xDD
15D6:  CLRF   xE0
15D8:  MOVLW  01
15DA:  MOVWF  xDF
15DC:  MOVLB  0
15DE:  RCALL  0F9A
.................... } 
15E0:  RETURN 0
....................  
.................... typedef void (*cmd_func)(void* message_payload); 
....................  
.................... typedef struct cmd_entry { 
....................   uint8_t opcode; 
....................   cmd_func func; 
.................... } cmd_entry; 
....................  
.................... static cmd_entry commands[] = { 
....................   { OP_SET_DATA_LINE_MESSAGE, handle_set_data_line_message }, 
....................   { OP_GET_DATA_LINE_MESSAGE, handle_get_data_line_message }, 
....................   { OP_VERSION_REQUEST_MESSAGE, handle_version_request_message }, 
....................   { OP_FINISH_UPDATE_PROCESS_MESSAGE, handle_finish_update_process_message }, 
.................... }; 
....................  
.................... static uint8_t message_buffer[MSG_MAX_MESSAGE_LEN]; 
....................  
.................... static void process_loader_message() { 
....................   message_t* message; 
....................   message = (message_t*)message_buffer; 
15E2:  MOVLW  02
15E4:  MOVLB  3
15E6:  MOVWF  x93
15E8:  MOVLW  3D
15EA:  MOVFF  393,38E
15EE:  MOVWF  x8D
....................   /* find the correct func */ 
....................   int i; 
....................   for(i=0;i<ARRAY_SIZE(commands); i++) { 
15F0:  CLRF   x8F
15F2:  MOVF   x8F,W
15F4:  SUBLW  03
15F6:  BNC   167A
....................     if(commands[i].opcode == message->opcode) { 
15F8:  MOVF   x8F,W
15FA:  MULLW  03
15FC:  MOVF   FF3,W
15FE:  CLRF   x93
1600:  MOVWF  x92
1602:  MOVLW  31
1604:  ADDWF  x92,W
1606:  MOVWF  FE9
1608:  MOVLW  02
160A:  ADDWFC x93,W
160C:  MOVWF  FEA
160E:  MOVFF  FEF,394
1612:  MOVFF  38D,FE9
1616:  MOVFF  38E,FEA
161A:  MOVF   FEF,W
161C:  SUBWF  x94,W
161E:  BNZ   1676
....................       //ugly hack to make p point to message->payload... 
....................       uint16_t p = message; 
1620:  MOVFF  38E,391
1624:  MOVFF  38D,390
....................       p += 1; 
1628:  MOVLW  01
162A:  ADDWF  x90,F
162C:  MOVLW  00
162E:  ADDWFC x91,F
....................       commands[i].func((uint16_t*)p); 
1630:  MOVF   x8F,W
1632:  MULLW  03
1634:  MOVF   FF3,W
1636:  CLRF   x93
1638:  MOVWF  x92
163A:  MOVLW  01
163C:  ADDWF  x92,W
163E:  MOVWF  01
1640:  MOVLW  00
1642:  ADDWFC x93,W
1644:  MOVWF  03
1646:  MOVF   01,W
1648:  ADDLW  31
164A:  MOVWF  FE9
164C:  MOVLW  02
164E:  ADDWFC 03,W
1650:  MOVWF  FEA
1652:  MOVFF  FEC,393
1656:  MOVF   FED,F
1658:  MOVFF  FEF,392
165C:  MOVLW  03
165E:  MOVWF  FEA
1660:  MOVLW  92
1662:  MOVWF  FE9
1664:  MOVFF  391,395
1668:  MOVFF  390,394
166C:  MOVLB  0
166E:  CALL   0942
....................       return; 
1672:  BRA    167A
1674:  MOVLB  3
....................     } 
....................   } 
1676:  INCF   x8F,F
1678:  BRA    15F2
167A:  MOVLB  0
.................... } 
167C:  GOTO   16A8 (RETURN)
....................  
.................... static void loader_main() { 
....................   while (1) { 
....................     uint16_t size; 
....................     bool res = comm_receive_message(message_buffer, &size); 
1680:  MOVLW  02
1682:  MOVLB  3
1684:  MOVWF  x8E
1686:  MOVLW  3D
1688:  MOVWF  x8D
168A:  MOVLW  03
168C:  MOVWF  x90
168E:  MOVLW  8A
1690:  MOVWF  x8F
1692:  MOVLB  0
1694:  GOTO   0E4A
1698:  MOVLB  3
169A:  BCF    x8C.0
169C:  BTFSC  01.0
169E:  BSF    x8C.0
....................     if (res) 
16A0:  BTFSS  x8C.0
16A2:  BRA    16A8
....................       process_loader_message(); 
16A4:  MOVLB  0
16A6:  BRA    15E2
....................   } 
16A8:  MOVLB  0
16AA:  BRA    1680
.................... } 
16AC:  GOTO   070A (RETURN)
....................  
.................... static void init_io_ports() { 
....................   //we only care about B1, the PROG_EN pin 
....................   output_high(PIN_B1); 
*
00F4:  BSF    F8A.1
....................   set_tris_b(0xFF);//set all B pins to input mode 
00F6:  MOVLW  FF
00F8:  MOVWF  F93
.................... } 
00FA:  GOTO   068E (RETURN)
....................  
.................... static void dummy_function() { 
.................... } 
00FE:  RETURN 0
....................  
.................... #org 0x100, 0x800 
.................... int main() { 
0100:  CLRF   FF8
0102:  BCF    FD0.7
0104:  BSF    07.7
0106:  CLRF   FEA
0108:  CLRF   FE9
010A:  MOVLW  70
010C:  MOVWF  FD3
010E:  BSF    F9B.6
0110:  BCF    F9B.7
0112:  CLRF   19
0114:  BSF    FB8.3
0116:  MOVLW  10
0118:  MOVWF  FAF
011A:  MOVLW  00
011C:  MOVWF  FB0
011E:  MOVLW  A6
0120:  MOVWF  FAC
0122:  MOVLW  90
0124:  MOVWF  FAB
0126:  CLRF   1D
0128:  CLRF   1C
012A:  CLRF   1B
012C:  CLRF   1A
012E:  MOVLW  35
0130:  MOVWF  FCD
0132:  CLRF   FCC
0134:  CLRF   FCF
0136:  CLRF   FCE
0138:  BCF    F9E.0
013A:  BCF    F92.4
013C:  BCF    F92.3
013E:  BCF    F89.3
0140:  BCF    F92.2
0142:  BCF    F89.2
0144:  MOVLW  70
0146:  MOVWF  FD3
0148:  BSF    F9B.6
014A:  BCF    F9B.7
014C:  MOVWF  FD3
014E:  BSF    F9B.6
0150:  BCF    F9B.7
0152:  MOVWF  FD3
0154:  BSF    F9B.6
0156:  BCF    F9B.7
0158:  MOVWF  FD3
015A:  BSF    F9B.6
015C:  BCF    F9B.7
015E:  MOVLB  3
0160:  SETF   x80
0162:  SETF   x7F
0164:  SETF   x7E
0166:  SETF   x7D
0168:  MOVF   FC1,W
016A:  ANDLW  F0
016C:  MOVWF  FC1
016E:  MOVLW  00
0170:  MOVLB  F
0172:  MOVWF  x38
0174:  MOVWF  x3C
0176:  MOVWF  x39
0178:  MOVWF  x3A
017A:  MOVWF  x3B
017C:  MOVLB  1
017E:  CLRF   x88
0180:  CLRF   F77
0182:  CLRF   F78
0184:  CLRF   F79
0186:  CLRF   1E
0188:  CLRF   1F
018A:  CLRF   20
018C:  CLRF   21
018E:  CLRF   22
0190:  CLRF   23
0192:  CLRF   24
0194:  CLRF   25
0196:  CLRF   26
0198:  CLRF   27
019A:  CLRF   28
019C:  CLRF   29
019E:  CLRF   2A
01A0:  CLRF   2B
01A2:  CLRF   2C
01A4:  CLRF   2D
01A6:  CLRF   2E
01A8:  CLRF   2F
01AA:  CLRF   30
01AC:  CLRF   31
01AE:  CLRF   32
01B0:  CLRF   33
01B2:  CLRF   34
01B4:  CLRF   35
01B6:  CLRF   36
01B8:  CLRF   37
01BA:  CLRF   38
01BC:  CLRF   39
01BE:  CLRF   3A
01C0:  CLRF   3B
01C2:  CLRF   3C
01C4:  CLRF   3D
01C6:  CLRF   3E
01C8:  CLRF   3F
01CA:  CLRF   40
01CC:  CLRF   41
01CE:  CLRF   42
01D0:  CLRF   43
01D2:  CLRF   44
01D4:  CLRF   45
01D6:  CLRF   46
01D8:  CLRF   47
01DA:  CLRF   48
01DC:  CLRF   49
01DE:  CLRF   4A
01E0:  CLRF   4B
01E2:  CLRF   4C
01E4:  CLRF   4D
01E6:  CLRF   4E
01E8:  CLRF   4F
01EA:  CLRF   50
01EC:  CLRF   51
01EE:  CLRF   52
01F0:  CLRF   53
01F2:  CLRF   54
01F4:  CLRF   55
01F6:  CLRF   56
01F8:  CLRF   57
01FA:  CLRF   58
01FC:  CLRF   59
01FE:  CLRF   5A
0200:  CLRF   5B
0202:  CLRF   5C
0204:  CLRF   5D
0206:  CLRF   5E
0208:  CLRF   5F
020A:  MOVLB  0
020C:  CLRF   x60
020E:  CLRF   x61
0210:  CLRF   x62
0212:  CLRF   x63
0214:  CLRF   x64
0216:  CLRF   x65
0218:  CLRF   x66
021A:  CLRF   x67
021C:  CLRF   x68
021E:  CLRF   x69
0220:  CLRF   x6A
0222:  CLRF   x6B
0224:  CLRF   x6C
0226:  CLRF   x6D
0228:  CLRF   x6E
022A:  CLRF   x6F
022C:  CLRF   x70
022E:  CLRF   x71
0230:  CLRF   x72
0232:  CLRF   x73
0234:  CLRF   x74
0236:  CLRF   x75
0238:  CLRF   x76
023A:  CLRF   x77
023C:  CLRF   x78
023E:  CLRF   x79
0240:  CLRF   x7A
0242:  CLRF   x7B
0244:  CLRF   x7C
0246:  CLRF   x7D
0248:  CLRF   x7E
024A:  CLRF   x7F
024C:  CLRF   x80
024E:  CLRF   x81
0250:  CLRF   x82
0252:  CLRF   x83
0254:  CLRF   x84
0256:  CLRF   x85
0258:  CLRF   x86
025A:  CLRF   x87
025C:  CLRF   x88
025E:  CLRF   x89
0260:  CLRF   x8A
0262:  CLRF   x8B
0264:  CLRF   x8C
0266:  CLRF   x8D
0268:  CLRF   x8E
026A:  CLRF   x8F
026C:  CLRF   x90
026E:  CLRF   x91
0270:  CLRF   x92
0272:  CLRF   x93
0274:  CLRF   x94
0276:  CLRF   x95
0278:  CLRF   x96
027A:  CLRF   x97
027C:  CLRF   x98
027E:  CLRF   x99
0280:  CLRF   x9A
0282:  CLRF   x9B
0284:  CLRF   x9C
0286:  CLRF   x9D
0288:  CLRF   x9E
028A:  CLRF   x9F
028C:  CLRF   xA0
028E:  CLRF   xA1
0290:  CLRF   xA2
0292:  CLRF   xA3
0294:  CLRF   xA4
0296:  CLRF   xA5
0298:  CLRF   xA6
029A:  CLRF   xA7
029C:  CLRF   xA8
029E:  CLRF   xA9
02A0:  CLRF   xAA
02A2:  CLRF   xAB
02A4:  CLRF   xAC
02A6:  CLRF   xAD
02A8:  CLRF   xAE
02AA:  CLRF   xAF
02AC:  CLRF   xB0
02AE:  CLRF   xB1
02B0:  CLRF   xB2
02B2:  CLRF   xB3
02B4:  CLRF   xB4
02B6:  CLRF   xB5
02B8:  CLRF   xB6
02BA:  CLRF   xB7
02BC:  CLRF   xB8
02BE:  CLRF   xB9
02C0:  CLRF   xBA
02C2:  CLRF   xBB
02C4:  CLRF   xBC
02C6:  CLRF   xBD
02C8:  CLRF   xBE
02CA:  CLRF   xBF
02CC:  CLRF   xC0
02CE:  CLRF   xC1
02D0:  CLRF   xC2
02D2:  CLRF   xC3
02D4:  CLRF   xC4
02D6:  CLRF   xC5
02D8:  CLRF   xC6
02DA:  CLRF   xC7
02DC:  CLRF   xC8
02DE:  CLRF   xC9
02E0:  CLRF   xCA
02E2:  CLRF   xCB
02E4:  CLRF   xCC
02E6:  CLRF   xCD
02E8:  CLRF   xCE
02EA:  CLRF   xCF
02EC:  CLRF   xD0
02EE:  CLRF   xD1
02F0:  CLRF   xD2
02F2:  CLRF   xD3
02F4:  CLRF   xD4
02F6:  CLRF   xD5
02F8:  CLRF   xD6
02FA:  CLRF   xD7
02FC:  CLRF   xD8
02FE:  CLRF   xD9
0300:  CLRF   xDA
0302:  CLRF   xDB
0304:  CLRF   xDC
0306:  CLRF   xDD
0308:  CLRF   xDE
030A:  CLRF   xDF
030C:  CLRF   xE0
030E:  CLRF   xE1
0310:  CLRF   xE2
0312:  CLRF   xE3
0314:  CLRF   xE4
0316:  CLRF   xE5
0318:  CLRF   xE6
031A:  CLRF   xE7
031C:  CLRF   xE8
031E:  CLRF   xE9
0320:  CLRF   xEA
0322:  CLRF   xEB
0324:  CLRF   xEC
0326:  CLRF   xED
0328:  CLRF   xEE
032A:  CLRF   xEF
032C:  CLRF   xF0
032E:  CLRF   xF1
0330:  CLRF   xF2
0332:  CLRF   xF3
0334:  CLRF   xF4
0336:  CLRF   xF5
0338:  CLRF   xF6
033A:  CLRF   xF7
033C:  CLRF   xF8
033E:  CLRF   xF9
0340:  CLRF   xFA
0342:  CLRF   xFB
0344:  CLRF   xFC
0346:  CLRF   xFD
0348:  CLRF   xFE
034A:  CLRF   xFF
034C:  MOVLB  1
034E:  CLRF   x00
0350:  CLRF   x01
0352:  CLRF   x02
0354:  CLRF   x03
0356:  CLRF   x04
0358:  CLRF   x05
035A:  CLRF   x06
035C:  CLRF   x07
035E:  CLRF   x08
0360:  CLRF   x09
0362:  CLRF   x0A
0364:  CLRF   x0B
0366:  CLRF   x0C
0368:  CLRF   x0D
036A:  CLRF   x0E
036C:  CLRF   x0F
036E:  CLRF   x10
0370:  CLRF   x11
0372:  CLRF   x12
0374:  CLRF   x13
0376:  CLRF   x14
0378:  CLRF   x15
037A:  CLRF   x16
037C:  CLRF   x17
037E:  CLRF   x18
0380:  CLRF   x19
0382:  CLRF   x1A
0384:  CLRF   x1B
0386:  CLRF   x1C
0388:  CLRF   x1D
038A:  CLRF   x1E
038C:  CLRF   x1F
038E:  CLRF   x20
0390:  CLRF   x21
0392:  CLRF   x22
0394:  CLRF   x23
0396:  CLRF   x24
0398:  CLRF   x25
039A:  CLRF   x26
039C:  CLRF   x27
039E:  CLRF   x28
03A0:  CLRF   x29
03A2:  CLRF   x2A
03A4:  CLRF   x2B
03A6:  CLRF   x2C
03A8:  CLRF   x2D
03AA:  CLRF   x2E
03AC:  CLRF   x2F
03AE:  CLRF   x30
03B0:  CLRF   x31
03B2:  CLRF   x32
03B4:  CLRF   x33
03B6:  CLRF   x34
03B8:  CLRF   x35
03BA:  CLRF   x36
03BC:  CLRF   x37
03BE:  CLRF   x38
03C0:  CLRF   x39
03C2:  CLRF   x3A
03C4:  CLRF   x3B
03C6:  CLRF   x3C
03C8:  CLRF   x3D
03CA:  CLRF   x3E
03CC:  CLRF   x3F
03CE:  CLRF   x40
03D0:  CLRF   x41
03D2:  CLRF   x42
03D4:  CLRF   x43
03D6:  CLRF   x44
03D8:  CLRF   x45
03DA:  CLRF   x46
03DC:  CLRF   x47
03DE:  CLRF   x48
03E0:  CLRF   x49
03E2:  CLRF   x4A
03E4:  CLRF   x4B
03E6:  CLRF   x4C
03E8:  CLRF   x4D
03EA:  CLRF   x4E
03EC:  CLRF   x4F
03EE:  CLRF   x50
03F0:  CLRF   x51
03F2:  CLRF   x52
03F4:  CLRF   x53
03F6:  CLRF   x54
03F8:  CLRF   x55
03FA:  CLRF   x56
03FC:  CLRF   x57
03FE:  CLRF   x58
0400:  CLRF   x59
0402:  CLRF   x5A
0404:  CLRF   x5B
0406:  CLRF   x5C
0408:  CLRF   x5D
040A:  CLRF   x5E
040C:  CLRF   x5F
040E:  CLRF   x60
0410:  CLRF   x61
0412:  CLRF   x62
0414:  CLRF   x63
0416:  CLRF   x64
0418:  CLRF   x65
041A:  CLRF   x66
041C:  CLRF   x67
041E:  CLRF   x68
0420:  CLRF   x69
0422:  CLRF   x6A
0424:  CLRF   x6B
0426:  CLRF   x6C
0428:  CLRF   x6D
042A:  CLRF   x6E
042C:  CLRF   x6F
042E:  CLRF   x70
0430:  CLRF   x71
0432:  CLRF   x72
0434:  CLRF   x73
0436:  CLRF   x74
0438:  CLRF   x75
043A:  CLRF   x76
043C:  CLRF   x77
043E:  CLRF   x78
0440:  CLRF   x79
0442:  CLRF   x7A
0444:  CLRF   x7B
0446:  CLRF   x7C
0448:  CLRF   x7D
044A:  CLRF   x7E
044C:  CLRF   x7F
044E:  CLRF   x80
0450:  CLRF   x81
0452:  CLRF   x82
0454:  CLRF   x83
0456:  CLRF   x84
0458:  CLRF   x85
045A:  CLRF   x86
045C:  CLRF   x87
045E:  CLRF   x88
0460:  CLRF   x89
0462:  CLRF   x8A
0464:  CLRF   x8B
0466:  CLRF   x8C
0468:  CLRF   x8D
046A:  CLRF   x8E
046C:  CLRF   x8F
046E:  CLRF   x90
0470:  CLRF   x91
0472:  CLRF   x92
0474:  CLRF   x93
0476:  CLRF   x94
0478:  CLRF   x95
047A:  CLRF   x96
047C:  CLRF   x97
047E:  CLRF   x98
0480:  CLRF   x99
0482:  CLRF   x9A
0484:  CLRF   x9B
0486:  CLRF   x9C
0488:  CLRF   x9D
048A:  CLRF   x9E
048C:  CLRF   x9F
048E:  CLRF   xA0
0490:  CLRF   xA1
0492:  CLRF   xA2
0494:  CLRF   xA3
0496:  CLRF   xA4
0498:  CLRF   xA5
049A:  CLRF   xA6
049C:  CLRF   xA7
049E:  CLRF   xA8
04A0:  CLRF   xA9
04A2:  CLRF   xAA
04A4:  CLRF   xAB
04A6:  CLRF   xAC
04A8:  CLRF   xAD
04AA:  CLRF   xAE
04AC:  CLRF   xAF
04AE:  CLRF   xB0
04B0:  CLRF   xB1
04B2:  CLRF   xB2
04B4:  CLRF   xB3
04B6:  CLRF   xB4
04B8:  CLRF   xB5
04BA:  CLRF   xB6
04BC:  CLRF   xB7
04BE:  CLRF   xB8
04C0:  CLRF   xB9
04C2:  CLRF   xBA
04C4:  CLRF   xBB
04C6:  CLRF   xBC
04C8:  CLRF   xBD
04CA:  CLRF   xBE
04CC:  CLRF   xBF
04CE:  CLRF   xC0
04D0:  CLRF   xC1
04D2:  CLRF   xC2
04D4:  CLRF   xC3
04D6:  CLRF   xC4
04D8:  CLRF   xC5
04DA:  CLRF   xC6
04DC:  CLRF   xC7
04DE:  CLRF   xC8
04E0:  CLRF   xC9
04E2:  CLRF   xCA
04E4:  CLRF   xCB
04E6:  CLRF   xCC
04E8:  CLRF   xCD
04EA:  CLRF   xCE
04EC:  CLRF   xCF
04EE:  CLRF   xD0
04F0:  CLRF   xD1
04F2:  CLRF   xD2
04F4:  CLRF   xD3
04F6:  CLRF   xD4
04F8:  CLRF   xD5
04FA:  CLRF   xD6
04FC:  CLRF   xD7
04FE:  CLRF   xD8
0500:  CLRF   xD9
0502:  CLRF   xDA
0504:  CLRF   xDB
0506:  CLRF   xDC
0508:  CLRF   xDD
050A:  CLRF   xDE
050C:  CLRF   xDF
050E:  CLRF   xE0
0510:  CLRF   xE1
0512:  CLRF   xE2
0514:  CLRF   xE3
0516:  CLRF   xE4
0518:  CLRF   xE5
051A:  CLRF   xE6
051C:  CLRF   xE7
051E:  CLRF   xE8
0520:  CLRF   xE9
0522:  CLRF   xEA
0524:  CLRF   xEB
0526:  CLRF   xEC
0528:  CLRF   xED
052A:  CLRF   xEE
052C:  CLRF   xEF
052E:  CLRF   xF0
0530:  CLRF   xF1
0532:  CLRF   xF2
0534:  CLRF   xF3
0536:  CLRF   xF4
0538:  CLRF   xF5
053A:  CLRF   xF6
053C:  CLRF   xF7
053E:  CLRF   xF8
0540:  CLRF   xF9
0542:  CLRF   xFA
0544:  CLRF   xFB
0546:  CLRF   xFC
0548:  CLRF   xFD
054A:  CLRF   xFE
054C:  CLRF   xFF
054E:  MOVLB  2
0550:  CLRF   x00
0552:  CLRF   x01
0554:  CLRF   x02
0556:  CLRF   x03
0558:  CLRF   x04
055A:  CLRF   x05
055C:  CLRF   x06
055E:  CLRF   x07
0560:  CLRF   x08
0562:  CLRF   x09
0564:  CLRF   x0A
0566:  CLRF   x0B
0568:  CLRF   x0C
056A:  CLRF   x0D
056C:  CLRF   x0E
056E:  CLRF   x0F
0570:  CLRF   x10
0572:  CLRF   x11
0574:  CLRF   x12
0576:  CLRF   x13
0578:  CLRF   x14
057A:  CLRF   x15
057C:  CLRF   x16
057E:  CLRF   x17
0580:  CLRF   x18
0582:  CLRF   x19
0584:  CLRF   x1A
0586:  CLRF   x1B
0588:  CLRF   x1C
058A:  CLRF   x1D
058C:  CLRF   x1E
058E:  CLRF   x1F
0590:  CLRF   x20
0592:  CLRF   x21
0594:  CLRF   x22
0596:  CLRF   x23
0598:  CLRF   x24
059A:  CLRF   x25
059C:  CLRF   x26
059E:  CLRF   x27
05A0:  CLRF   x28
05A2:  CLRF   x29
05A4:  CLRF   x2A
05A6:  CLRF   x2B
05A8:  CLRF   x2C
05AA:  CLRF   x2D
05AC:  CLRF   x2E
05AE:  CLRF   x2F
05B0:  CLRF   x30
05B2:  MOVLW  06
05B4:  MOVWF  x31
05B6:  MOVLW  12
05B8:  MOVWF  x33
05BA:  MOVLW  EE
05BC:  MOVWF  x32
05BE:  MOVLW  07
05C0:  MOVWF  x34
05C2:  MOVLW  14
05C4:  MOVWF  x36
05C6:  MOVLW  7E
05C8:  MOVWF  x35
05CA:  MOVLW  02
05CC:  MOVWF  x37
05CE:  MOVLW  15
05D0:  MOVWF  x39
05D2:  MOVLW  72
05D4:  MOVWF  x38
05D6:  MOVLW  08
05D8:  MOVWF  x3A
05DA:  MOVLW  15
05DC:  MOVWF  x3C
05DE:  MOVLW  BA
05E0:  MOVWF  x3B
05E2:  CLRF   x3D
05E4:  CLRF   x3E
05E6:  CLRF   x3F
05E8:  CLRF   x40
05EA:  CLRF   x41
05EC:  CLRF   x42
05EE:  CLRF   x43
05F0:  CLRF   x44
05F2:  CLRF   x45
05F4:  CLRF   x46
05F6:  CLRF   x47
05F8:  CLRF   x48
05FA:  CLRF   x49
05FC:  CLRF   x4A
05FE:  CLRF   x4B
0600:  CLRF   x4C
0602:  CLRF   x4D
0604:  CLRF   x4E
0606:  CLRF   x4F
0608:  CLRF   x50
060A:  CLRF   x51
060C:  CLRF   x52
060E:  CLRF   x53
0610:  CLRF   x54
0612:  CLRF   x55
0614:  CLRF   x56
0616:  CLRF   x57
0618:  CLRF   x58
061A:  CLRF   x59
061C:  CLRF   x5A
061E:  CLRF   x5B
0620:  CLRF   x5C
0622:  CLRF   x5D
0624:  CLRF   x5E
0626:  CLRF   x5F
0628:  CLRF   x60
062A:  CLRF   x61
062C:  CLRF   x62
062E:  CLRF   x63
0630:  CLRF   x64
0632:  CLRF   x65
0634:  CLRF   x66
0636:  CLRF   x67
0638:  CLRF   x68
063A:  CLRF   x69
063C:  CLRF   x6A
063E:  CLRF   x6B
0640:  CLRF   x6C
0642:  CLRF   x6D
0644:  CLRF   x6E
0646:  CLRF   x6F
0648:  CLRF   x70
064A:  CLRF   x71
064C:  CLRF   x72
064E:  CLRF   x73
0650:  CLRF   x74
0652:  CLRF   x75
0654:  CLRF   x76
0656:  CLRF   x77
0658:  CLRF   x78
065A:  CLRF   x79
065C:  CLRF   x7A
065E:  CLRF   x7B
0660:  CLRF   x7C
0662:  CLRF   x7D
0664:  CLRF   x7E
0666:  CLRF   x7F
0668:  CLRF   x80
066A:  CLRF   x81
066C:  CLRF   x82
066E:  CLRF   x83
0670:  CLRF   x84
0672:  CLRF   x85
0674:  CLRF   x86
0676:  CLRF   x87
0678:  CLRF   x88
067A:  CLRF   x89
067C:  CLRF   x8A
067E:  CLRF   x8B
0680:  CLRF   x8C
....................   disable_interrupts(GLOBAL);//probably unnecessary but just to be safe... 
0682:  BCF    FF2.6
0684:  BCF    FF2.7
0686:  BTFSC  FF2.7
0688:  BRA    0684
....................   init_io_ports(); 
068A:  MOVLB  0
068C:  BRA    00F4
....................  
....................   int delay_time = 10000; 
....................   int delay_count = BOOT_WAIT_TIME_US / delay_time; 
....................   bool start_loader = true; 
....................   bootloader_metadata_t *metadata = get_metadata(); 
068E:  MOVLW  10
0690:  MOVLB  3
0692:  MOVWF  x81
0694:  BCF    FD8.1
0696:  CLRF   x8D
0698:  MOVLW  07
069A:  MOVWF  x8C
069C:  MOVLW  A1
069E:  MOVWF  x8B
06A0:  MOVLW  20
06A2:  MOVWF  x8A
06A4:  CLRF   x91
06A6:  CLRF   x90
06A8:  CLRF   x8F
06AA:  MOVFF  381,38E
06AE:  MOVLB  0
06B0:  BRA    0950
06B2:  MOVFF  00,382
06B6:  MOVLB  3
06B8:  BSF    x83.0
06BA:  MOVLB  0
06BC:  RCALL  0A04
06BE:  MOVFF  02,385
06C2:  MOVFF  01,384
....................  
....................   if (!metadata->run_loader) { //otherwise we always want the bootloader 
06C6:  MOVLB  3
06C8:  MOVFF  384,FE9
06CC:  MOVFF  385,FEA
06D0:  BTFSC  FEF.0
06D2:  BRA    06F8
....................     for (int i = 0; i < delay_count; ++i) { 
06D4:  CLRF   x86
06D6:  MOVF   x82,W
06D8:  SUBWF  x86,W
06DA:  BC    06F8
....................       int value = input(PIN_B1); 
....................       if (value == 1) { 
*
06E2:  DECFSZ x87,W
06E4:  BRA    06EA
....................         start_loader = false; 
06E6:  BCF    x83.0
....................         break; 
06E8:  BRA    06F8
....................       } 
....................       delay_us(delay_time); 
06EA:  MOVFF  381,38A
06EE:  MOVLB  0
06F0:  BRA    0A2A
....................     }   
06F2:  MOVLB  3
06F4:  INCF   x86,F
06F6:  BRA    06D6
....................   } 
....................  
....................   if (start_loader) { 
06F8:  BTFSS  x83.0
06FA:  BRA    0714
....................     fix_first_page(); 
06FC:  MOVLB  0
06FE:  BRA    0B60
....................     comm_init(); 
0700:  BRA    0C68
....................     enable_interrupts(GLOBAL); 
0702:  MOVLW  C0
0704:  IORWF  FF2,F
....................     loader_main(); 
0706:  GOTO   1680
....................     return 0; 
070A:  MOVLW  00
070C:  MOVWF  01
070E:  BRA    0736
....................   } 
....................   else { 
0710:  BRA    0736
0712:  MOVLB  3
....................     void (*real_main)(void); 
....................     real_main = dummy_function;//hack to overcome a compilation error 
0714:  MOVLW  00
0716:  MOVWF  03
0718:  MOVLW  FE
071A:  MOVWF  x88
071C:  MOVFF  03,389
....................     real_main = (void*)MAIN_ADDRESS; 
0720:  MOVLW  27
0722:  MOVWF  x89
0724:  CLRF   x88
....................     real_main(); 
0726:  MOVLW  03
0728:  MOVWF  FEA
072A:  MOVLW  88
072C:  MOVWF  FE9
072E:  MOVLB  0
0730:  RCALL  0942
....................     return 0; 
0732:  MOVLW  00
0734:  MOVWF  01
....................   } 
.................... } 
....................  
.................... #include "BA1474.h" 
.................... #include <18F45K22.h> 
0736:  BRA    0736
.................... //////// Standard Header file for the PIC18F45K22 device //////////////// 
.................... #device PIC18F45K22 
.................... #list 
....................  
.................... #device adc=10 
.................... #device pass_strings=in_ram 
....................  
.................... #define LOADER_END 0x1FFF 
.................... #include <boot.h> 
.................... #undef LOADER_END 
.................... #define FLASH_SIZE getenv("FLASH_ERASE_SIZE") 
.................... #define LOADER_END   0x1FFF 
.................... #define LOADER_SIZE  0x3FF 
....................  
.................... #ifndef _bootloader 
.................... #build(reset=LOADER_END+1, interrupt=LOADER_END+9) 
....................  
.................... /* when in operational software, keep out of the bootloader sections */ 
.................... #org 0, 0xfff {} 
.................... #org 0x1000, 0x1ffe {} 
....................  
.................... #else 
....................  
.................... /* when in the bootloader, keep out of the operational sections */ 
.................... #org 0x2000, 0x7ffe {} 
....................  
.................... #endif 
....................  
....................  
.................... #FUSES NOWDT                   //No Watch Dog Timer 
.................... #FUSES WDT128                  //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES INTRC_IO                //Internal RC Osc, no CLKOUT 
.................... #FUSES NOBROWNOUT              //No brownout reset 
.................... #FUSES WDT_SW                  //No Watch Dog Timer, enabled in Software 
.................... #FUSES NOLVP                   //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOPUT 
.................... #FUSES NOXINST                 //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(clock=64000000) 
.................... #use rs232(baud=921600,xmit=PIN_C6,rcv=PIN_C7,ERRORS) 
.................... #USE TIMER(TIMER=1,TICK=1us,BITS=32,NOISR) 
.................... #use spi(DO=PIN_A4, CLK=PIN_A3, ENABLE=PIN_A2, ENABLE_ACTIVE=0, DATA_HOLD=20, BITS=16) 
....................  
.................... #opt 9 
....................  
.................... #use fast_io(a) 
.................... #use fast_io(b) 
.................... #use fast_io(c) 
.................... #use fast_io(d) 
.................... #use fast_io(e) 
....................  
.................... #define safe_write_program_memory(address, pointer, size) \ 
....................   do { disable_interrupts(GLOBAL); write_program_memory(address, pointer, size); enable_interrupts(GLOBAL); delay_us(1000); } while (0) 
....................  
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdbool.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                          stdbool.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard boolean definitions                                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __STDBOOL_H__ 
.................... #define __STDBOOL_H__ 
....................  
.................... //remove TRUE and FALSE added by CCS's device .h file 
.................... #if defined(TRUE) 
.................... #undef TRUE 
.................... #endif 
.................... #if defined(FALSE) 
.................... #undef FALSE 
.................... #endif 
....................  
.................... typedef int1   bool; 
.................... #define true   1 
.................... #define false  0 
.................... #define __bool_true_false_are_defined  1 
....................  
.................... #endif 
....................  
.................... #include "timer.h" 
.................... #ifndef INCLUDE_TIMER_H_ 
.................... #define INCLUDE_TIMER_H_ 
....................  
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdbool.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                          stdbool.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard boolean definitions                                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __STDBOOL_H__ 
.................... #define __STDBOOL_H__ 
....................  
.................... //remove TRUE and FALSE added by CCS's device .h file 
.................... #if defined(TRUE) 
.................... #undef TRUE 
.................... #endif 
.................... #if defined(FALSE) 
.................... #undef FALSE 
.................... #endif 
....................  
.................... typedef int1   bool; 
.................... #define true   1 
.................... #define false  0 
.................... #define __bool_true_false_are_defined  1 
....................  
.................... #endif 
....................  
....................  
.................... typedef void (*timer_func)(void* arg); 
....................  
.................... typedef struct { 
....................   //bool triggred; 
....................   uint32_t expTime; 
....................   void *arg; 
....................   timer_func func; 
.................... } timer_task_t; 
....................  
.................... #INLINE 
.................... uint32_t timer_get_us_count(); 
.................... bool timer_registerTask(uint32_t expTime, timer_func func, void *arg); 
.................... void timer_yield(); 
....................  
.................... #endif /* INCLUDE_TIMER_H_ */ 
....................  
.................... #include "message_handlers.h" 
.................... /* 
....................  * message_handlers.h 
....................  * 
....................  *  Created on: Mar 26, 2017 
....................  *      Author: asaf 
....................  */ 
....................  
.................... #ifndef MESSAGE_HANDLERS_H_ 
.................... #define MESSAGE_HANDLERS_H_ 
....................  
.................... void init_message_handlers(); 
.................... void process_message(uint8_t* message, uint16_t length); 
.................... #INLINE 
.................... void perform_last_control_message(); 
.................... void control_handle_timer(); 
.................... void samp_if_needed(); 
....................  
.................... #endif /* MESSAGE_HANDLERS_H_ */ 
....................  
....................  
.................... #INLINE 
.................... uint32_t timer_get_us_count() { 
....................     return get_ticks(); 
.................... } 
....................  
.................... #define TIMER_TASKS_NUM 30 
.................... timer_task_t timerTasks[TIMER_TASKS_NUM]; 
.................... uint32_t timerTriggered = 0xffffffff; 
....................  
.................... bool timer_registerTask(uint32_t expTime, timer_func func, void *arg) { 
....................     uint32_t i; 
....................     for (i=0;i<TIMER_TASKS_NUM;i++) { 
....................           if((timerTriggered & (uint32_t)(1 << i)) != 0) { 
....................             /* use this pos */ 
....................             timerTriggered &= ~((uint32_t)1 << i); 
....................             timerTasks[i].expTime = expTime; 
....................             timerTasks[i].func = func; 
....................             timerTasks[i].arg = arg; 
....................             return true; 
....................         } 
....................     } 
....................     return false; 
.................... } 
....................  
.................... void timer_checkRunTask() { 
....................     int i; 
....................     uint32_t t = timer_get_us_count(); 
....................     for (i=0;i<TIMER_TASKS_NUM;i++) { 
....................         if((timerTriggered & (((uint32_t)1) << i)) == 0) { 
....................             if(t >= timerTasks[i].expTime) { 
....................                 timerTriggered |= ((uint32_t)1 << i); 
....................                 timerTasks[i].func(timerTasks[i].arg); 
....................             } 
....................         } 
....................     } 
.................... } 
....................  
.................... /* in case a function can spare some CPU time */ 
.................... void timer_yield() { 
.................... #ifndef _bootloader 
....................     timer_checkRunTask(); 
.................... #endif 
.................... } 
....................  

Configuration Fuses:
   Word  1: F800   INTRC_IO PLLEN PRIMARY_ON FCMEN IESO
   Word  2: 1C19   NOPUT NOBROWNOUT BORV19 NOWDT WDT128
   Word  3: BF00   CCP2C1 PBADEN CCP3B5 HFOFST TIMER3C0 CCP2D2 MCLR
   Word  4: 0000   NOSTVREN NOLVP NOXINST DEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.
